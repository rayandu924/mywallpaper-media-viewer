<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Media Viewer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="container">
    <div id="media-wrapper">
      <!-- Dynamic media element will be inserted here -->
    </div>
    <div id="fallback" class="hidden">
      <div class="fallback-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
          <circle cx="8.5" cy="8.5" r="1.5"/>
          <polyline points="21,15 16,10 5,21"/>
        </svg>
      </div>
      <p id="fallback-text">Media unavailable</p>
    </div>
    <div id="loading" class="hidden">
      <div class="spinner"></div>
    </div>
  </div>

  <script>
    // ==========================================================================
    // Media Viewer Addon - MyWallpaper SDK v2.17.1
    // ==========================================================================
    // Supports: Images (jpg, png, gif, webp, svg, ico, bmp, avif)
    //           Videos (mp4, webm, ogg, mov)
    //           Audio  (mp3, wav, ogg, flac, aac, m4a, opus, weba)
    //           External URLs and uploaded files
    //           Video platforms (YouTube, Vimeo, Twitch, Dailymotion)
    //
    // File access via SDK api.files API (FileReference handling)
    // Audio playback via parent-managed api.audio (sandbox restrictions)
    // ==========================================================================

    (function() {
      'use strict';

      // Get API reference (may be injected later)
      let api = window.MyWallpaper;

      // DOM Elements
      const container = document.getElementById('container');
      const mediaWrapper = document.getElementById('media-wrapper');
      const fallbackEl = document.getElementById('fallback');
      const fallbackText = document.getElementById('fallback-text');
      const loadingEl = document.getElementById('loading');

      // State
      let currentMediaEl = null;
      let refreshTimer = null;
      let isPaused = false;
      let audioUnsubscribe = null;  // Unsubscribe function for audio state listener
      let usingParentAudio = false; // Whether we're using parent-managed audio

      /**
       * Resolve a setting value to a usable URL with mimeType
       * Handles: FileReference (via SDK api.files) and direct URLs
       * Returns: { url: string, mimeType: string } or null
       */
      async function resolveSettingValue(value, settingKey) {
        // FileReference → SDK file access API
        if (api.files && api.files.isFileReference(value)) {
          const result = await api.files.request(settingKey);
          if (result && result.granted && result.blobUrl) {
            return { url: result.blobUrl, mimeType: '' };
          }
          return null;
        }

        // Direct URL/data URL
        if (typeof value === 'string' && value.length > 0) {
          let mimeType = '';
          if (value.startsWith('data:')) {
            const match = value.match(/^data:([^;,]+)/);
            if (match) mimeType = match[1];
          }
          return { url: value, mimeType };
        }

        return null;
      }

      // Media type detection
      const VIDEO_EXTENSIONS = ['mp4', 'webm', 'ogg', 'mov', 'm4v', 'avi', 'mkv'];
      const IMAGE_EXTENSIONS = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'ico', 'bmp', 'avif', 'tiff'];
      const AUDIO_EXTENSIONS = ['mp3', 'wav', 'ogg', 'flac', 'aac', 'm4a', 'opus', 'weba', 'wma'];

      // Embed platforms configuration
      const EMBED_PLATFORMS = {
        youtube: {
          patterns: [
            /youtube\.com\/watch\?v=([^&]+)/,
            /youtube\.com\/embed\/([^?]+)/,
            /youtu\.be\/([^?]+)/,
            /youtube\.com\/shorts\/([^?]+)/
          ],
          // Use youtube.com directly (not nocookie) with minimal parameters
          // Adding origin parameter helps with postMessage communication
          embedUrl: (id, opts) => {
            const params = new URLSearchParams({
              autoplay: opts.autoplay ? '1' : '0',
              mute: opts.muted ? '1' : '0',
              loop: opts.loop ? '1' : '0',
              rel: '0',
              modestbranding: '1',
              playsinline: '1',
              // These parameters help with sandboxed contexts
              enablejsapi: '0',  // Disable JS API to avoid errors
              origin: window.location.origin
            });
            return `https://www.youtube.com/embed/${id}?${params.toString()}`;
          }
        },
        vimeo: {
          patterns: [/vimeo\.com\/(\d+)/],
          embedUrl: (id, opts) =>
            `https://player.vimeo.com/video/${id}?autoplay=${opts.autoplay ? 1 : 0}&muted=${opts.muted ? 1 : 0}&loop=${opts.loop ? 1 : 0}&background=1`
        },
        twitch: {
          patterns: [
            /twitch\.tv\/videos\/(\d+)/,
            /twitch\.tv\/([^/?]+)$/
          ],
          embedUrl: (id, opts, isVideo) => {
            const parent = location.hostname || 'localhost';
            return isVideo
              ? `https://player.twitch.tv/?video=${id}&parent=${parent}&autoplay=${opts.autoplay}`
              : `https://player.twitch.tv/?channel=${id}&parent=${parent}&autoplay=${opts.autoplay}&muted=${opts.muted}`;
          }
        },
        dailymotion: {
          patterns: [/dailymotion\.com\/video\/([^_?]+)/],
          embedUrl: (id, opts) =>
            `https://www.dailymotion.com/embed/video/${id}?autoplay=${opts.autoplay ? 1 : 0}&mute=${opts.muted ? 1 : 0}`
        }
      };

      // ==========================================================================
      // UTILITY FUNCTIONS
      // ==========================================================================

      /**
       * Determine media type from URL and/or mimeType
       * @param {string} url - The media URL
       * @param {string} mimeType - Optional MIME type from blob
       * @returns {'video'|'image'|'audio'|'unknown'|null}
       */
      function getMediaType(url, mimeType = '') {
        if (!url) return null;

        // First, check mimeType if provided (most reliable for blobs)
        if (mimeType) {
          if (mimeType.startsWith('video/')) return 'video';
          if (mimeType.startsWith('image/')) return 'image';
          if (mimeType.startsWith('audio/')) return 'audio';
        }

        // Check for data URLs
        if (url.startsWith('data:')) {
          if (url.startsWith('data:video/')) return 'video';
          if (url.startsWith('data:image/')) return 'image';
          if (url.startsWith('data:audio/')) return 'audio';
          return null;
        }

        // Check for blob URLs - if no mimeType provided, return unknown
        if (url.startsWith('blob:')) {
          // If we have no mimeType, we can't determine the type
          return 'unknown';
        }

        // Extract extension from URL
        try {
          const urlObj = new URL(url);
          const pathname = urlObj.pathname.toLowerCase();
          const extension = pathname.split('.').pop();

          if (VIDEO_EXTENSIONS.includes(extension)) return 'video';
          if (IMAGE_EXTENSIONS.includes(extension)) return 'image';
          if (AUDIO_EXTENSIONS.includes(extension)) return 'audio';
        } catch (e) {
          // Invalid URL, try extension from string
          const extension = url.split('.').pop()?.toLowerCase().split('?')[0];
          if (VIDEO_EXTENSIONS.includes(extension)) return 'video';
          if (IMAGE_EXTENSIONS.includes(extension)) return 'image';
          if (AUDIO_EXTENSIONS.includes(extension)) return 'audio';
        }

        // Check common video hosting patterns
        if (url.includes('youtube.com') || url.includes('youtu.be') ||
            url.includes('vimeo.com') || url.includes('dailymotion.com')) {
          // Note: Direct embedding would require iframe, not supported in sandbox
          return null;
        }

        return 'unknown';
      }

      function buildFilterString(settings) {
        const filters = [];

        if (settings.blur > 0) {
          filters.push(`blur(${settings.blur}px)`);
        }
        if (settings.brightness !== 100) {
          filters.push(`brightness(${settings.brightness}%)`);
        }
        if (settings.contrast !== 100) {
          filters.push(`contrast(${settings.contrast}%)`);
        }
        if (settings.saturate !== 100) {
          filters.push(`saturate(${settings.saturate}%)`);
        }
        if (settings.hueRotate > 0) {
          filters.push(`hue-rotate(${settings.hueRotate}deg)`);
        }

        return filters.length > 0 ? filters.join(' ') : 'none';
      }

      function parseEmbedUrl(url, settings) {
        if (!url) return null;

        const opts = {
          autoplay: settings.autoplay ?? true,
          muted: settings.muted ?? true,
          loop: settings.loop ?? false
        };

        for (const [platform, config] of Object.entries(EMBED_PLATFORMS)) {
          for (let i = 0; i < config.patterns.length; i++) {
            const pattern = config.patterns[i];
            const match = url.match(pattern);
            if (match) {
              const id = match[1];
              // For Twitch, check if it's a video or channel
              const isVideo = platform === 'twitch' && url.includes('/videos/');
              return {
                platform,
                embedUrl: config.embedUrl(id, opts, isVideo),
                videoId: id
              };
            }
          }
        }

        return null; // Platform not recognized
      }

      function showLoading() {
        loadingEl.classList.remove('hidden');
        fallbackEl.classList.add('hidden');
      }

      function hideLoading() {
        loadingEl.classList.add('hidden');
      }

      function showFallback(message) {
        hideLoading();
        fallbackText.textContent = message || api.config.fallbackText || 'Media unavailable';
        fallbackEl.classList.remove('hidden');
        if (currentMediaEl) {
          currentMediaEl.classList.add('hidden');
        }
      }

      function hideFallback() {
        fallbackEl.classList.add('hidden');
      }

      // ==========================================================================
      // MEDIA CREATION
      // ==========================================================================

      function createImageElement(url, settings) {
        const img = document.createElement('img');
        img.className = 'media-element';
        img.alt = 'Media content';
        img.draggable = false;

        let loadHandled = false;

        const handleLoad = () => {
          if (loadHandled) return;
          if (!img.parentNode) {
            setTimeout(() => {
              if (!loadHandled && img.parentNode) handleLoad();
            }, 10);
            return;
          }
          loadHandled = true;
          hideLoading();
          hideFallback();
          img.classList.remove('hidden');
          console.log('[MediaViewer] Image handleLoad → applying styles, objectFit:', settings.objectFit, 'objectPosition:', settings.objectPosition);
          applyStyles(img, settings);
          api.renderComplete();
        };

        img.onload = handleLoad;

        img.onerror = () => {
          if (loadHandled) return;
          loadHandled = true;
          console.error('[MediaViewer] Failed to load image:', url);
          showFallback(settings.fallbackText);
          api.renderComplete();
        };

        img.src = url;

        // Handle synchronously cached images
        if (img.complete && img.naturalWidth > 0) {
          setTimeout(() => handleLoad(), 0);
        }

        return img;
      }

      function createVideoElement(url, settings, mimeType = '') {
        const video = document.createElement('video');
        video.className = 'media-element';

        // IMPORTANT: Video is ALWAYS muted in the iframe due to sandbox restrictions
        // Audio is handled by the parent via api.audio (parent-managed audio)
        video.autoplay = settings.autoplay && !isPaused;
        video.loop = settings.loop;
        video.muted = true;  // Always muted - audio via parent
        video.volume = 1;    // Volume doesn't matter when muted
        video.controls = settings.showControls;
        video.playbackRate = settings.playbackRate;
        video.playsInline = true;
        video.preload = 'auto';

        // Track if we've already signaled render complete
        let renderCompleted = false;
        const signalRenderComplete = () => {
          if (!renderCompleted) {
            renderCompleted = true;
            hideLoading();
            hideFallback();
            video.classList.remove('hidden');
            api.renderComplete();
          }
        };

        // Fallback timeout: signal render complete after 8s even if video not fully loaded
        // This prevents blocking thumbnail generation for slow-loading videos
        const loadTimeout = setTimeout(() => {
          if (!renderCompleted) {
            console.warn('[MediaViewer] Video load timeout (8s), signaling render complete anyway');
            signalRenderComplete();
          }
        }, 8000);

        video.onloadeddata = () => {
          clearTimeout(loadTimeout);
          console.log('[MediaViewer] Video onloadeddata → applying styles, objectFit:', settings.objectFit, 'objectPosition:', settings.objectPosition);
          applyStyles(video, settings);
          signalRenderComplete();

          if (!settings.muted) {
            startParentAudio(settings);
          }
        };

        video.onerror = (e) => {
          clearTimeout(loadTimeout);
          if (video.readyState > 0 || video.networkState === 2) return;
          console.error('[MediaViewer] Failed to load video:', video.error?.code, video.error?.message);
          showFallback(settings.fallbackText);
          api.renderComplete();
        };

        video.onplay = () => {
          if (usingParentAudio) api.audio.resume();
        };

        video.onpause = () => {
          if (usingParentAudio && !video.ended) api.audio.pause();
        };

        video.onseeked = () => {
          if (usingParentAudio) api.audio.seek(video.currentTime);
        };

        video.onended = () => {
          if (usingParentAudio && !settings.loop) api.audio.stop();
        };

        if (url.startsWith('data:') || url.startsWith('blob:')) {
          video.src = url;
        } else {
          const source = document.createElement('source');
          source.src = url;

          // Try to determine MIME type from extension or use provided mimeType
          let detectedMimeType = mimeType;
          if (!detectedMimeType) {
            const ext = url.split('.').pop()?.toLowerCase().split('?')[0];
            const mimeTypes = {
              mp4: 'video/mp4',
              webm: 'video/webm',
              ogg: 'video/ogg',
              mov: 'video/quicktime',
              m4v: 'video/mp4'
            };
            detectedMimeType = mimeTypes[ext] || '';
          }

          if (detectedMimeType) {
            source.type = detectedMimeType;
          }

          video.appendChild(source);
        }

        return video;
      }

      /**
       * Start parent-managed audio for video
       * The parent plays the same audio source and we sync playback
       */
      function startParentAudio(settings) {
        usingParentAudio = true;

        // Clean up previous listener
        if (audioUnsubscribe) {
          audioUnsubscribe();
          audioUnsubscribe = null;
        }

        // Get the audio source - use mediaFile settingKey for file sources
        const source = settings.sourceType === 'file' ? 'mediaFile' : settings.mediaUrl;

        // Play audio via parent with current settings
        api.audio.play(source, {
          volume: (settings.volume ?? 80) / 100,
          loop: settings.loop,
          playbackRate: settings.playbackRate,
          startTime: currentMediaEl?.currentTime || 0
        });

        audioUnsubscribe = api.audio.onStateChange((state) => {
          if (!currentMediaEl || currentMediaEl.tagName !== 'VIDEO') return;
          if (state.status === 'playing') {
            const drift = Math.abs(currentMediaEl.currentTime - state.currentTime);
            if (drift > 0.3) currentMediaEl.currentTime = state.currentTime;
          }
        });
      }

      /**
       * Stop parent-managed audio
       */
      function stopParentAudio() {
        if (usingParentAudio) {
          api.audio.stop();
          usingParentAudio = false;
          if (audioUnsubscribe) {
            audioUnsubscribe();
            audioUnsubscribe = null;
          }
        }
      }

      function createAudioElement(url, settings, mimeType = '') {
        const audio = document.createElement('audio');
        audio.className = 'media-element audio-element';

        // Audio attributes
        audio.autoplay = settings.autoplay && !isPaused;
        audio.loop = settings.loop;
        audio.muted = settings.muted;
        audio.volume = (settings.volume ?? 80) / 100;
        audio.controls = settings.showControls ?? true;  // Show controls by default for audio
        audio.playbackRate = settings.playbackRate ?? 1;
        audio.preload = 'auto';

        audio.onloadeddata = () => {
          hideLoading();
          hideFallback();
          audio.classList.remove('hidden');
          api.renderComplete();
        };

        audio.onerror = () => {
          console.error('[MediaViewer] Failed to load audio:', audio.error?.code, audio.error?.message);
          showFallback(settings.fallbackText);
          api.renderComplete();
        };

        if (url.startsWith('data:') || url.startsWith('blob:')) {
          audio.src = url;
        } else {
          const source = document.createElement('source');
          source.src = url;

          // Try to determine MIME type from extension or use provided mimeType
          let detectedMimeType = mimeType;
          if (!detectedMimeType) {
            const ext = url.split('.').pop()?.toLowerCase().split('?')[0];
            const mimeTypes = {
              mp3: 'audio/mpeg',
              wav: 'audio/wav',
              ogg: 'audio/ogg',
              flac: 'audio/flac',
              aac: 'audio/aac',
              m4a: 'audio/mp4',
              opus: 'audio/opus',
              weba: 'audio/webm',
              wma: 'audio/x-ms-wma'
            };
            detectedMimeType = mimeTypes[ext] || '';
          }

          if (detectedMimeType) {
            source.type = detectedMimeType;
          }

          audio.appendChild(source);
        }

        return audio;
      }

      function createEmbedElement(embedData, settings) {
        const iframe = document.createElement('iframe');
        iframe.className = 'media-element embed-frame';
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
        iframe.allowFullscreen = true;
        iframe.setAttribute('referrerpolicy', 'no-referrer-when-downgrade');

        // For cross-origin iframes, onload may not fire reliably
        // Show iframe immediately and hide loading after a short delay
        iframe.onload = () => {
          hideLoading();
          hideFallback();
          api.renderComplete();
        };

        iframe.onerror = () => {
          console.error(`[MediaViewer] Failed to load ${embedData.platform} embed`);
          showFallback(`Failed to load ${embedData.platform} video`);
          api.renderComplete(); // Signal done even on error
        };

        // Set src after setting up handlers
        iframe.src = embedData.embedUrl;

        // Fallback: if onload doesn't fire within 3s, show anyway
        setTimeout(() => {
          hideLoading();
          hideFallback();
        }, 3000);

        return iframe;
      }

      // ==========================================================================
      // APPLY SETTINGS
      // ==========================================================================

      function applyStyles(element, settings) {
        if (!element) {
          console.warn('[MediaViewer] applyStyles called with null element');
          return;
        }

        const fit = settings.objectFit || 'contain';
        const pos = settings.objectPosition || 'center';
        element.style.objectFit = fit;
        element.style.objectPosition = pos;
        element.style.opacity = (settings.opacity ?? 100) / 100;
        element.style.filter = buildFilterString(settings);
        element.style.borderRadius = `${settings.borderRadius || 0}px`;

        // Debug: verify styles were actually applied
        const computed = window.getComputedStyle(element);
        console.log('[MediaViewer] applyStyles →', {
          tag: element.tagName,
          objectFit: { requested: fit, inline: element.style.objectFit, computed: computed.objectFit },
          objectPosition: { requested: pos, inline: element.style.objectPosition, computed: computed.objectPosition },
          dimensions: { w: computed.width, h: computed.height },
          inDOM: !!element.parentNode
        });
      }

      function applyContainerStyles(settings) {
        container.style.backgroundColor = settings.backgroundColor || 'transparent';
        container.style.borderRadius = `${settings.borderRadius || 0}px`;
      }

      function applyVideoSettings(video, settings) {
        if (!video || video.tagName !== 'VIDEO') return;

        // For VIDEO elements, video is always muted (audio via parent)
        video.loop = settings.loop;
        video.controls = settings.showControls;

        if (video.playbackRate !== settings.playbackRate) {
          video.playbackRate = settings.playbackRate;
        }

        // Handle muted setting changes via parent audio
        if (!settings.muted && !usingParentAudio) {
          // User wants sound - start parent audio
          startParentAudio(settings);
        } else if (settings.muted && usingParentAudio) {
          // User muted - stop parent audio
          stopParentAudio();
        }

        // Sync audio settings with parent
        if (usingParentAudio) {
          api.audio.setVolume((settings.volume ?? 80) / 100);
          api.audio.setLoop(settings.loop);
          api.audio.setPlaybackRate(settings.playbackRate);
        }

        // Handle autoplay changes
        if (settings.autoplay && video.paused && !isPaused) {
          video.play().catch(e => console.log('[MediaViewer] Autoplay blocked:', e));
        } else if (!settings.autoplay && !video.paused) {
          video.pause();
        }
      }

      function applyAudioElementSettings(audio, settings) {
        if (!audio || audio.tagName !== 'AUDIO') return;

        // For AUDIO elements (not video), we still use parent audio API
        audio.loop = settings.loop;
        audio.controls = settings.showControls ?? true;

        // Handle autoplay changes
        if (settings.autoplay && audio.paused && !isPaused) {
          audio.play().catch(e => console.log('[MediaViewer] Autoplay blocked:', e));
        } else if (!settings.autoplay && !audio.paused) {
          audio.pause();
        }
      }

      // ==========================================================================
      // MEDIA LOADING
      // ==========================================================================

      async function getMediaSource(settings) {
        // Use sourceType to determine which field to use
        switch (settings.sourceType) {
          case 'file':
            // Resolve placeholder/FileReference to actual blob URL with mimeType
            const fileResult = await resolveSettingValue(settings.mediaFile, 'mediaFile');
            if (fileResult) {
              return { type: 'file', url: fileResult.url, mimeType: fileResult.mimeType };
            }
            return { type: 'file', url: null, mimeType: '' };
          case 'url':
          default:
            const urlResult = await resolveSettingValue(settings.mediaUrl, 'mediaUrl');
            if (urlResult) {
              return { type: 'url', url: urlResult.url, mimeType: urlResult.mimeType };
            }
            return { type: 'url', url: settings.mediaUrl || null, mimeType: '' };
        }
      }

      // Guard to prevent race conditions when multiple loadMedia calls overlap
      let loadMediaVersion = 0;

      async function loadMedia(settings) {
        const thisVersion = ++loadMediaVersion;

        showLoading();

        const source = await getMediaSource(settings);

        if (thisVersion !== loadMediaVersion) return;

        // Request network permission for external URLs
        if (source.type === 'url' && source.url && !source.url.startsWith('data:') && !source.url.startsWith('blob:')) {
          try {
            const domain = new URL(source.url).hostname;
            if (api.network && api.network.requestAccess) {
              const accessResult = await api.network.requestAccess(domain, `Load media from ${domain}`);
              if (!accessResult.granted) {
                showFallback('Network access denied');
                api.renderComplete();
                return;
              }
            }
          } catch (e) {
            // Invalid URL - continue anyway
          }
        }

        if (!source.url) {
          const messages = {
            'file': 'No file uploaded',
            'url': 'No URL configured'
          };
          showFallback(messages[settings.sourceType] || 'No URL configured');
          api.renderComplete(); // Signal done even with no media
          return;
        }

        // Check if data URL is truncated
        if (source.url.length < 50 && source.url.startsWith('data:')) {
          showFallback('File data is corrupted or too large');
          api.renderComplete();
          return;
        }

        // Clear previous media
        if (currentMediaEl) {
          if (currentMediaEl.tagName === 'VIDEO' || currentMediaEl.tagName === 'AUDIO') {
            currentMediaEl.pause();
            // Remove error handler before cleanup to prevent spurious error events
            currentMediaEl.onerror = null;
            currentMediaEl.onloadeddata = null;
          }
          currentMediaEl.remove();
          currentMediaEl = null;
        }

        const mediaUrl = source.url;

        // For URL sources, try to detect embed platforms first
        if (source.type === 'url') {
          const embedData = parseEmbedUrl(source.url, settings);
          if (embedData) {
            currentMediaEl = createEmbedElement(embedData, settings);
            applyStyles(currentMediaEl, settings);
            applyContainerStyles(settings);
            mediaWrapper.appendChild(currentMediaEl);
            return;
          }
        }

        const mediaType = getMediaType(source.url, source.mimeType);

        if (mediaType === 'video') {
          currentMediaEl = createVideoElement(mediaUrl, settings, source.mimeType);
        } else if (mediaType === 'audio') {
          currentMediaEl = createAudioElement(mediaUrl, settings, source.mimeType);
        } else if (mediaType === 'image') {
          currentMediaEl = createImageElement(mediaUrl, settings);
        } else if (mediaType === 'unknown') {
          // Try as image first, then video, then audio
          currentMediaEl = createImageElement(mediaUrl, settings);
          currentMediaEl.onerror = () => {
            console.log('[MediaViewer] Image failed, trying as video');
            currentMediaEl.remove();
            currentMediaEl = createVideoElement(mediaUrl, settings, source.mimeType);
            currentMediaEl.onerror = () => {
              console.log('[MediaViewer] Video failed, trying as audio');
              currentMediaEl.remove();
              currentMediaEl = createAudioElement(mediaUrl, settings, source.mimeType);
              applyStyles(currentMediaEl, settings);
              mediaWrapper.appendChild(currentMediaEl);
            };
            applyStyles(currentMediaEl, settings);
            mediaWrapper.appendChild(currentMediaEl);
          };
        } else {
          showFallback('Unsupported media type');
          api.renderComplete(); // Signal done even on error
          return;
        }

        applyStyles(currentMediaEl, settings);
        applyContainerStyles(settings);
        mediaWrapper.appendChild(currentMediaEl);
      }

      function setupRefreshTimer(intervalMinutes) {
        if (refreshTimer) {
          clearInterval(refreshTimer);
          refreshTimer = null;
        }

        if (intervalMinutes > 0) {
          const intervalMs = intervalMinutes * 60 * 1000;
          refreshTimer = setInterval(() => loadMedia(api.config), intervalMs);
        }
      }

      // ==========================================================================
      // EVENT HANDLERS
      // ==========================================================================

      api.onSettingsChange((settings, changedKeys) => {
        console.log('[MediaViewer] Settings changed:', changedKeys, {
          objectFit: settings.objectFit,
          objectPosition: settings.objectPosition,
          currentMediaEl: currentMediaEl?.tagName || 'null'
        });

        // Check if media source changed
        const mediaChanged = changedKeys.includes('mediaUrl') ||
                            changedKeys.includes('mediaFile') ||
                            changedKeys.includes('sourceType');

        if (mediaChanged) {
          // Stop current audio before loading new media
          stopParentAudio();
          loadMedia(settings);
        } else {
          console.log('[MediaViewer] Applying style changes (no media reload)');
          applyStyles(currentMediaEl, settings);
          applyContainerStyles(settings);

          // Element-specific settings
          if (currentMediaEl?.tagName === 'VIDEO') {
            applyVideoSettings(currentMediaEl, settings);
          } else if (currentMediaEl?.tagName === 'AUDIO') {
            applyAudioElementSettings(currentMediaEl, settings);
          }
        }

        // Handle refresh interval change
        if (changedKeys.includes('refreshInterval')) {
          setupRefreshTimer(settings.refreshInterval);
        }

        // Update fallback text
        if (changedKeys.includes('fallbackText') && !fallbackEl.classList.contains('hidden')) {
          fallbackText.textContent = settings.fallbackText;
        }
      });

      api.onEvent('viewport:resize', () => {
        // Media elements auto-resize via CSS, no action needed
      });

      api.onEvent('theme:change', ({ theme }) => {
        document.body.dataset.theme = theme;
      });

      api.onEvent('visibility:change', ({ visible }) => {
        const isPlayableMedia = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';

        if (isPlayableMedia) {
          if (!visible && !currentMediaEl.paused) {
            currentMediaEl.pause();
            // Also pause parent audio
            if (usingParentAudio) {
              api.audio.pause();
            }
          } else if (visible && api.config.autoplay && !isPaused) {
            currentMediaEl.play().catch(() => {});
            // Also resume parent audio
            if (usingParentAudio) {
              api.audio.resume();
            }
          }
        }
      });

      api.onUnmount(() => {
        if (refreshTimer) clearInterval(refreshTimer);
        stopParentAudio();
        if (currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO') {
          currentMediaEl.pause();
        }
        if (api.files) api.files.revoke('mediaFile');
      });

      api.onPause(() => {
        isPaused = true;
        const isPlayableMedia = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';
        if (isPlayableMedia && !currentMediaEl.paused) {
          currentMediaEl.pause();
        }
        // Also pause parent audio
        if (usingParentAudio) {
          api.audio.pause();
        }
      });

      api.onResume(() => {
        isPaused = false;
        const isPlayableMedia = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';
        if (isPlayableMedia && api.config.autoplay) {
          currentMediaEl.play().catch(() => {});
        }
        // Also resume parent audio
        if (usingParentAudio) {
          api.audio.resume();
        }
      });

      // ==========================================================================
      // INITIALIZATION
      // ==========================================================================

      async function init() {
        api = window.MyWallpaper;

        if (!api) {
          console.error('[MediaViewer] SDK not available!');
          return;
        }

        try {
          await loadMedia(api.config || {});
          setupRefreshTimer((api.config || {}).refreshInterval);
        } catch (e) {
          console.error('[MediaViewer] Error loading media:', e);
          api.renderComplete();
        }

        api.ready({
          capabilities: ['hot-reload'],
          subscribedEvents: ['viewport:resize', 'theme:change', 'visibility:change']
        });

        console.log('[MediaViewer] Ready, SDK v' + api.version);
      }

      if (window.MyWallpaper) {
        init();
      } else {
        window.addEventListener('mywallpaper:ready', init);
      }

    })();
  </script>
</body>
</html>
