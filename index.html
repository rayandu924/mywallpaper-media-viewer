<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Media Viewer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="container">
    <div id="media-wrapper">
      <!-- Dynamic media element will be inserted here -->
    </div>
    <div id="fallback" class="hidden">
      <div class="fallback-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
          <circle cx="8.5" cy="8.5" r="1.5"/>
          <polyline points="21,15 16,10 5,21"/>
        </svg>
      </div>
      <p id="fallback-text">Media unavailable</p>
    </div>
    <div id="loading" class="hidden">
      <div class="spinner"></div>
    </div>
  </div>

  <script>
    // ==========================================================================
    // Media Viewer Addon - MyWallpaper SDK v2.6
    // ==========================================================================
    // Supports: Images (jpg, png, gif, webp, svg, ico, bmp, avif)
    //           Videos (mp4, webm, ogg, mov)
    //           Audio  (mp3, wav, ogg, flac, aac, m4a, opus, weba)
    //           External URLs and uploaded files
    //           Separate audio track overlay for silent videos
    // ==========================================================================

    (function() {
      'use strict';

      const api = window.MyWallpaper;

      // DOM Elements
      const container = document.getElementById('container');
      const mediaWrapper = document.getElementById('media-wrapper');
      const fallbackEl = document.getElementById('fallback');
      const fallbackText = document.getElementById('fallback-text');
      const loadingEl = document.getElementById('loading');

      // State
      let currentMediaEl = null;
      let audioTrackEl = null;  // Separate audio track element
      let refreshTimer = null;
      let isPaused = false;

      // ==========================================================================
      // FILE ACCESS SUPPORT (NEW v2.6 API)
      // ==========================================================================
      // Files are now sent as FileReference objects instead of data URLs.
      // We must request access via api.files.request() which shows a user modal.

      // Cache of granted blob URLs (settingKey -> blobUrl)
      const grantedBlobUrls = new Map();

      // Pending file access requests (settingKey -> Promise)
      const pendingRequests = new Map();

      /**
       * Check if a value is a FileReference (new v2.6 format)
       */
      function isFileReference(value) {
        return value && typeof value === 'object' && value.__type === 'file-reference';
      }

      /**
       * Request file access and get blob URL
       * Returns null if denied or not yet granted
       *
       * The host sends the Blob object itself (not a blob URL) because:
       * - This iframe runs in about:srcdoc origin (null/opaque)
       * - Blob URLs are origin-scoped and cannot be accessed cross-origin
       * - We receive the Blob via structured clone algorithm
       * - We create our own blob URL in our own context
       */
      async function requestFileAccess(settingKey, fileRef) {
        // Already granted?
        if (grantedBlobUrls.has(settingKey)) {
          return grantedBlobUrls.get(settingKey);
        }

        // Already requesting?
        if (pendingRequests.has(settingKey)) {
          return pendingRequests.get(settingKey);
        }

        console.log(`[MediaViewer] Requesting file access for ${settingKey}: ${fileRef.filename}`);

        // Create promise for this request
        const requestPromise = new Promise((resolve) => {
          // Listen for FILE_ACCESS_RESPONSE
          const handler = (event) => {
            // Debug: log all messages from host
            if (event.data?.source === 'MyWallpaperHost') {
              console.log('[MediaViewer] Received message from host:', event.data.type, event.data);
            }

            if (event.data?.type === 'FILE_ACCESS_RESPONSE' &&
                event.data?.source === 'MyWallpaperHost' &&
                event.data?.settingKey === settingKey) {

              window.removeEventListener('message', handler);
              pendingRequests.delete(settingKey);

              console.log('[MediaViewer] FILE_ACCESS_RESPONSE received:', {
                granted: event.data.granted,
                hasBlob: !!event.data.blob,
                blobType: event.data.blob ? event.data.blob.constructor.name : 'N/A',
                isBlob: event.data.blob instanceof Blob,
                mimeType: event.data.mimeType,
                size: event.data.size
              });

              if (event.data.granted && event.data.blob instanceof Blob) {
                // Create our own blob URL from the received Blob
                const blobUrl = URL.createObjectURL(event.data.blob);
                console.log(`[MediaViewer] File access granted for ${settingKey}, created blob URL: ${blobUrl.substring(0, 50)}...`);
                grantedBlobUrls.set(settingKey, blobUrl);
                resolve(blobUrl);
                // Reload media now that we have the blob URL
                if (api.config) {
                  console.log('[MediaViewer] Reloading media after file access granted');
                  loadMedia(api.config);
                }
              } else if (event.data.granted && event.data.blob) {
                // Blob might not be detected as instanceof Blob in sandboxed context
                // Try to create blob URL anyway
                console.log('[MediaViewer] Blob not detected as instanceof Blob, trying anyway...');
                try {
                  const blobUrl = URL.createObjectURL(event.data.blob);
                  console.log(`[MediaViewer] Successfully created blob URL: ${blobUrl.substring(0, 50)}...`);
                  grantedBlobUrls.set(settingKey, blobUrl);
                  resolve(blobUrl);
                  // Reload media now that we have the blob URL
                  if (api.config) {
                    console.log('[MediaViewer] Reloading media after file access granted');
                    loadMedia(api.config);
                  }
                } catch (e) {
                  console.error('[MediaViewer] Failed to create blob URL:', e);
                  resolve(null);
                }
              } else {
                console.log(`[MediaViewer] File access denied for ${settingKey}`);
                resolve(null);
              }
            }
          };

          window.addEventListener('message', handler);

          // Send request to host
          window.parent.postMessage({
            type: 'FILE_ACCESS_REQUEST',
            layerId: api.layerId,
            settingKey: settingKey,
            requestId: `${settingKey}-${Date.now()}`
          }, '*');
        });

        pendingRequests.set(settingKey, requestPromise);
        return requestPromise;
      }

      // ==========================================================================
      // LEGACY BLOB TRANSFER SUPPORT (for backwards compatibility)
      // ==========================================================================
      // Keep support for old FILE_BLOB messages in case host hasn't updated

      const receivedBlobs = new Map();  // Map<placeholderId, blobUrl>

      window.addEventListener('message', (event) => {
        // Legacy FILE_BLOB support
        if (event.data?.type === 'FILE_BLOB' && event.data?.source === 'MyWallpaperHost') {
          const { settingKey, placeholderId, blob, mimeType } = event.data;

          if (blob && blob instanceof Blob) {
            const blobUrl = URL.createObjectURL(blob);
            receivedBlobs.set(placeholderId, blobUrl);
            console.log(`[MediaViewer] Received legacy blob for ${settingKey}: ${blobUrl.substring(0, 50)}... (${blob.size} bytes, ${mimeType})`);

            if (api.config) {
              const needsReload =
                api.config.mediaFile === placeholderId ||
                api.config.audioTrackFile === placeholderId;

              if (needsReload) {
                console.log('[MediaViewer] Blob received for pending media, reloading...');
                loadMedia(api.config);
              }
            }
          }
        }
      });

      /**
       * Resolve a setting value to a usable URL
       * Handles: FileReference, blob placeholders, and direct URLs
       */
      async function resolveSettingValue(value, settingKey) {
        // NEW: FileReference object (v2.6)
        if (isFileReference(value)) {
          return await requestFileAccess(settingKey, value);
        }

        // Legacy: blob placeholder string
        if (typeof value === 'string' && value.startsWith('__blob_')) {
          const blobUrl = receivedBlobs.get(value);
          if (blobUrl) {
            console.log('[MediaViewer] Resolved legacy placeholder to blob URL');
            return blobUrl;
          }
          console.log('[MediaViewer] Waiting for legacy blob:', value);
          return null;
        }

        // Direct URL/data URL
        return value;
      }

      // Media type detection
      const VIDEO_EXTENSIONS = ['mp4', 'webm', 'ogg', 'mov', 'm4v', 'avi', 'mkv'];
      const IMAGE_EXTENSIONS = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'ico', 'bmp', 'avif', 'tiff'];
      const AUDIO_EXTENSIONS = ['mp3', 'wav', 'ogg', 'flac', 'aac', 'm4a', 'opus', 'weba', 'wma'];

      // Cache for converted blob URLs to avoid memory leaks
      const blobUrlCache = new Map();

      /**
       * Check if we're in a sandboxed context where blob URLs won't work
       * In srcdoc iframes WITHOUT allow-same-origin, the origin is "null" and blob:null/... URLs fail
       */
      function isNullOrigin() {
        try {
          // If we can access window.origin and it's not 'null', we have same-origin
          return window.origin === 'null' || window.location.origin === 'null';
        } catch (e) {
          // If we can't access, assume null origin
          return true;
        }
      }

      /**
       * Convert data URL to Blob URL to bypass CSP restrictions
       * CSP often allows blob: but blocks data: for media-src
       * With allow-same-origin, blob URLs work properly
       */
      function dataUrlToBlobUrl(dataUrl) {
        // Check if we're in null-origin context
        const nullOrigin = isNullOrigin();
        console.log('[MediaViewer] Origin check - isNullOrigin:', nullOrigin, 'window.origin:', window.origin);

        // In null-origin contexts, blob URLs don't work - use data URL directly
        // But this may fail for large videos!
        if (nullOrigin) {
          console.log('[MediaViewer] Null origin detected, using data URL directly (may fail for large files)');
          return dataUrl;
        }

        // Check cache first
        if (blobUrlCache.has(dataUrl)) {
          return blobUrlCache.get(dataUrl);
        }

        try {
          // Parse data URL
          const [header, base64Data] = dataUrl.split(',');
          const mimeMatch = header.match(/data:([^;]+)/);
          if (!mimeMatch) return dataUrl;

          const mimeType = mimeMatch[1];
          const byteCharacters = atob(base64Data);
          const byteNumbers = new Array(byteCharacters.length);

          for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
          }

          const byteArray = new Uint8Array(byteNumbers);
          const blob = new Blob([byteArray], { type: mimeType });
          const blobUrl = URL.createObjectURL(blob);

          // Cache it
          blobUrlCache.set(dataUrl, blobUrl);
          console.log('[MediaViewer] Converted data URL to blob URL:', blobUrl.substring(0, 50));

          return blobUrl;
        } catch (e) {
          console.error('[MediaViewer] Failed to convert data URL to blob:', e);
          return dataUrl;
        }
      }

      /**
       * Prepare URL for use - converts data URLs to blob URLs if needed
       */
      function prepareMediaUrl(url) {
        if (!url) return null;
        if (url.startsWith('data:')) {
          return dataUrlToBlobUrl(url);
        }
        return url;
      }

      // Embed platforms configuration
      const EMBED_PLATFORMS = {
        youtube: {
          patterns: [
            /youtube\.com\/watch\?v=([^&]+)/,
            /youtube\.com\/embed\/([^?]+)/,
            /youtu\.be\/([^?]+)/,
            /youtube\.com\/shorts\/([^?]+)/
          ],
          // Use youtube.com directly (not nocookie) with minimal parameters
          // Adding origin parameter helps with postMessage communication
          embedUrl: (id, opts) => {
            const params = new URLSearchParams({
              autoplay: opts.autoplay ? '1' : '0',
              mute: opts.muted ? '1' : '0',
              loop: opts.loop ? '1' : '0',
              rel: '0',
              modestbranding: '1',
              playsinline: '1',
              // These parameters help with sandboxed contexts
              enablejsapi: '0',  // Disable JS API to avoid errors
              origin: window.location.origin
            });
            return `https://www.youtube.com/embed/${id}?${params.toString()}`;
          }
        },
        vimeo: {
          patterns: [/vimeo\.com\/(\d+)/],
          embedUrl: (id, opts) =>
            `https://player.vimeo.com/video/${id}?autoplay=${opts.autoplay ? 1 : 0}&muted=${opts.muted ? 1 : 0}&loop=${opts.loop ? 1 : 0}&background=1`
        },
        twitch: {
          patterns: [
            /twitch\.tv\/videos\/(\d+)/,
            /twitch\.tv\/([^/?]+)$/
          ],
          embedUrl: (id, opts, isVideo) => {
            const parent = location.hostname || 'localhost';
            return isVideo
              ? `https://player.twitch.tv/?video=${id}&parent=${parent}&autoplay=${opts.autoplay}`
              : `https://player.twitch.tv/?channel=${id}&parent=${parent}&autoplay=${opts.autoplay}&muted=${opts.muted}`;
          }
        },
        dailymotion: {
          patterns: [/dailymotion\.com\/video\/([^_?]+)/],
          embedUrl: (id, opts) =>
            `https://www.dailymotion.com/embed/video/${id}?autoplay=${opts.autoplay ? 1 : 0}&mute=${opts.muted ? 1 : 0}`
        }
      };

      // ==========================================================================
      // UTILITY FUNCTIONS
      // ==========================================================================

      function getMediaType(url) {
        if (!url) return null;

        // Check for data URLs
        if (url.startsWith('data:')) {
          if (url.startsWith('data:video/')) return 'video';
          if (url.startsWith('data:image/')) return 'image';
          if (url.startsWith('data:audio/')) return 'audio';
          return null;
        }

        // Check for blob URLs
        if (url.startsWith('blob:')) {
          // Can't determine from URL, will try video first then image
          return 'unknown';
        }

        // Extract extension from URL
        try {
          const urlObj = new URL(url);
          const pathname = urlObj.pathname.toLowerCase();
          const extension = pathname.split('.').pop();

          if (VIDEO_EXTENSIONS.includes(extension)) return 'video';
          if (IMAGE_EXTENSIONS.includes(extension)) return 'image';
          if (AUDIO_EXTENSIONS.includes(extension)) return 'audio';
        } catch (e) {
          // Invalid URL, try extension from string
          const extension = url.split('.').pop()?.toLowerCase().split('?')[0];
          if (VIDEO_EXTENSIONS.includes(extension)) return 'video';
          if (IMAGE_EXTENSIONS.includes(extension)) return 'image';
          if (AUDIO_EXTENSIONS.includes(extension)) return 'audio';
        }

        // Check common video hosting patterns
        if (url.includes('youtube.com') || url.includes('youtu.be') ||
            url.includes('vimeo.com') || url.includes('dailymotion.com')) {
          // Note: Direct embedding would require iframe, not supported in sandbox
          return null;
        }

        return 'unknown';
      }

      function buildFilterString(settings) {
        const filters = [];

        if (settings.blur > 0) {
          filters.push(`blur(${settings.blur}px)`);
        }
        if (settings.brightness !== 100) {
          filters.push(`brightness(${settings.brightness}%)`);
        }
        if (settings.contrast !== 100) {
          filters.push(`contrast(${settings.contrast}%)`);
        }
        if (settings.saturate !== 100) {
          filters.push(`saturate(${settings.saturate}%)`);
        }
        if (settings.hueRotate > 0) {
          filters.push(`hue-rotate(${settings.hueRotate}deg)`);
        }

        return filters.length > 0 ? filters.join(' ') : 'none';
      }

      function parseEmbedUrl(url, settings) {
        if (!url) return null;

        const opts = {
          autoplay: settings.autoplay ?? true,
          muted: settings.muted ?? true,
          loop: settings.loop ?? false
        };

        for (const [platform, config] of Object.entries(EMBED_PLATFORMS)) {
          for (let i = 0; i < config.patterns.length; i++) {
            const pattern = config.patterns[i];
            const match = url.match(pattern);
            if (match) {
              const id = match[1];
              // For Twitch, check if it's a video or channel
              const isVideo = platform === 'twitch' && url.includes('/videos/');
              return {
                platform,
                embedUrl: config.embedUrl(id, opts, isVideo),
                videoId: id
              };
            }
          }
        }

        return null; // Platform not recognized
      }

      function showLoading() {
        loadingEl.classList.remove('hidden');
        fallbackEl.classList.add('hidden');
      }

      function hideLoading() {
        loadingEl.classList.add('hidden');
      }

      function showFallback(message) {
        hideLoading();
        fallbackText.textContent = message || api.config.fallbackText || 'Media unavailable';
        fallbackEl.classList.remove('hidden');
        if (currentMediaEl) {
          currentMediaEl.classList.add('hidden');
        }
      }

      function hideFallback() {
        fallbackEl.classList.add('hidden');
      }

      // ==========================================================================
      // MEDIA CREATION
      // ==========================================================================

      function createImageElement(url, settings) {
        const img = document.createElement('img');
        img.className = 'media-element';
        img.alt = 'Media content';
        img.draggable = false;

        img.onload = () => {
          hideLoading();
          hideFallback();
          img.classList.remove('hidden');
          api.renderComplete();
        };

        img.onerror = () => {
          console.error('[MediaViewer] Failed to load image:', url);
          showFallback(settings.fallbackText);
        };

        img.src = url;
        return img;
      }

      function createVideoElement(url, settings) {
        const video = document.createElement('video');
        video.className = 'media-element';

        // Video attributes
        video.autoplay = settings.autoplay && !isPaused;
        video.loop = settings.loop;
        video.muted = settings.muted;
        video.volume = (settings.volume ?? 80) / 100;  // Convert 0-100 to 0-1
        video.controls = settings.showControls;
        video.playbackRate = settings.playbackRate;
        video.playsInline = true;
        video.preload = 'auto';

        video.onloadeddata = () => {
          hideLoading();
          hideFallback();
          video.classList.remove('hidden');
          api.renderComplete();
        };

        video.onerror = (e) => {
          console.error('[MediaViewer] Failed to load video:', url.substring(0, 100) + '...', e);
          console.error('[MediaViewer] Video error code:', video.error?.code, 'message:', video.error?.message);
          showFallback(settings.fallbackText);
        };

        // Handle autoplay failures (browser restrictions)
        video.onplay = () => {
          console.log('[MediaViewer] Video playing');
        };

        // For data URLs, set src directly instead of using source element
        // Some browsers handle data URLs better this way
        if (url.startsWith('data:')) {
          console.log('[MediaViewer] Setting video.src with data URL, length:', url.length);
          video.src = url;
          console.log('[MediaViewer] After assignment, video.src length:', video.src.length);
          console.log('[MediaViewer] Video readyState:', video.readyState);
          console.log('[MediaViewer] Video networkState:', video.networkState);
        } else {
          const source = document.createElement('source');
          source.src = url;

          // Try to determine MIME type
          const ext = url.split('.').pop()?.toLowerCase().split('?')[0];
          const mimeTypes = {
            mp4: 'video/mp4',
            webm: 'video/webm',
            ogg: 'video/ogg',
            mov: 'video/quicktime',
            m4v: 'video/mp4'
          };
          if (mimeTypes[ext]) {
            source.type = mimeTypes[ext];
          }

          video.appendChild(source);
        }

        return video;
      }

      function createAudioElement(url, settings) {
        const audio = document.createElement('audio');
        audio.className = 'media-element audio-element';

        // Audio attributes
        audio.autoplay = settings.autoplay && !isPaused;
        audio.loop = settings.loop;
        audio.muted = settings.muted;
        audio.volume = (settings.volume ?? 80) / 100;
        audio.controls = settings.showControls ?? true;  // Show controls by default for audio
        audio.playbackRate = settings.playbackRate ?? 1;
        audio.preload = 'auto';

        audio.onloadeddata = () => {
          hideLoading();
          hideFallback();
          audio.classList.remove('hidden');
          api.renderComplete();
        };

        audio.onerror = (e) => {
          console.error('[MediaViewer] Failed to load audio:', url, e);
          showFallback(settings.fallbackText);
        };

        audio.onplay = () => {
          console.log('[MediaViewer] Audio playing');
        };

        const source = document.createElement('source');
        source.src = url;

        // Try to determine MIME type
        const ext = url.split('.').pop()?.toLowerCase().split('?')[0];
        const mimeTypes = {
          mp3: 'audio/mpeg',
          wav: 'audio/wav',
          ogg: 'audio/ogg',
          flac: 'audio/flac',
          aac: 'audio/aac',
          m4a: 'audio/mp4',
          opus: 'audio/opus',
          weba: 'audio/webm',
          wma: 'audio/x-ms-wma'
        };
        if (mimeTypes[ext]) {
          source.type = mimeTypes[ext];
        }

        audio.appendChild(source);
        return audio;
      }

      function createEmbedElement(embedData, settings) {
        const iframe = document.createElement('iframe');
        iframe.className = 'media-element embed-frame';
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
        iframe.allowFullscreen = true;
        iframe.setAttribute('referrerpolicy', 'no-referrer-when-downgrade');

        // For cross-origin iframes, onload may not fire reliably
        // Show iframe immediately and hide loading after a short delay
        iframe.onload = () => {
          hideLoading();
          hideFallback();
          api.renderComplete();
          console.log(`[MediaViewer] ${embedData.platform} embed loaded`);
        };

        iframe.onerror = () => {
          console.error(`[MediaViewer] Failed to load ${embedData.platform} embed`);
          showFallback(`Failed to load ${embedData.platform} video`);
        };

        // Set src after setting up handlers
        iframe.src = embedData.embedUrl;

        // Fallback: if onload doesn't fire within 3s, show anyway
        setTimeout(() => {
          hideLoading();
          hideFallback();
        }, 3000);

        return iframe;
      }

      // ==========================================================================
      // APPLY SETTINGS
      // ==========================================================================

      function applyStyles(element, settings) {
        if (!element) return;

        element.style.objectFit = settings.objectFit || 'contain';
        element.style.objectPosition = settings.objectPosition || 'center';
        element.style.opacity = (settings.opacity ?? 100) / 100;
        element.style.filter = buildFilterString(settings);
        element.style.borderRadius = `${settings.borderRadius || 0}px`;
      }

      function applyContainerStyles(settings) {
        container.style.backgroundColor = settings.backgroundColor || 'transparent';
        container.style.borderRadius = `${settings.borderRadius || 0}px`;
      }

      function applyVideoSettings(video, settings) {
        if (!video || (video.tagName !== 'VIDEO' && video.tagName !== 'AUDIO')) return;

        video.loop = settings.loop;
        video.muted = settings.muted;
        video.volume = (settings.volume ?? 80) / 100;
        video.controls = settings.showControls;

        if (video.playbackRate !== settings.playbackRate) {
          video.playbackRate = settings.playbackRate;
        }

        // Handle autoplay changes
        if (settings.autoplay && video.paused && !isPaused) {
          video.play().catch(e => console.log('[MediaViewer] Autoplay blocked:', e));
        } else if (!settings.autoplay && !video.paused) {
          video.pause();
        }
      }

      function applyAudioTrackSettings(audioTrack, settings) {
        if (!audioTrack) return;

        audioTrack.loop = settings.loop;
        audioTrack.muted = settings.muted;
        audioTrack.volume = (settings.volume ?? 80) / 100;
        audioTrack.playbackRate = settings.playbackRate ?? 1;
      }

      // ==========================================================================
      // MEDIA LOADING
      // ==========================================================================

      async function getMediaSource(settings) {
        // Use sourceType to determine which field to use
        switch (settings.sourceType) {
          case 'file':
            // Resolve placeholder/FileReference to actual blob URL
            const fileUrl = await resolveSettingValue(settings.mediaFile, 'mediaFile');
            return { type: 'file', url: fileUrl || null };
          case 'url':
          default:
            return { type: 'url', url: settings.mediaUrl || null };
        }
      }

      async function getAudioTrackSource(settings) {
        if (!settings.audioTrackEnabled) return null;

        switch (settings.audioTrackSourceType) {
          case 'file':
            // Resolve placeholder/FileReference to actual blob URL
            return await resolveSettingValue(settings.audioTrackFile, 'audioTrackFile') || null;
          case 'url':
          default:
            return settings.audioTrackUrl || null;
        }
      }

      async function loadAudioTrack(settings) {
        // Clean up existing audio track
        if (audioTrackEl) {
          audioTrackEl.pause();
          audioTrackEl.src = '';
          audioTrackEl.remove();
          audioTrackEl = null;
        }

        const audioUrl = await getAudioTrackSource(settings);
        if (!audioUrl) return;

        const preparedUrl = prepareMediaUrl(audioUrl);
        console.log('[MediaViewer] Loading audio track:', preparedUrl.substring(0, 50) + '...');

        audioTrackEl = document.createElement('audio');
        audioTrackEl.className = 'audio-track-element';
        audioTrackEl.autoplay = settings.autoplay && !isPaused;
        audioTrackEl.loop = settings.loop;
        audioTrackEl.muted = settings.muted;
        audioTrackEl.volume = (settings.volume ?? 80) / 100;
        audioTrackEl.playbackRate = settings.playbackRate ?? 1;
        audioTrackEl.preload = 'auto';
        audioTrackEl.style.display = 'none';  // Hidden audio element

        audioTrackEl.onloadeddata = () => {
          console.log('[MediaViewer] Audio track loaded');
          // Sync with video if it exists
          if (currentMediaEl?.tagName === 'VIDEO' && !currentMediaEl.paused) {
            audioTrackEl.currentTime = currentMediaEl.currentTime;
            audioTrackEl.play().catch(() => {});
          }
        };

        audioTrackEl.onerror = (e) => {
          console.error('[MediaViewer] Failed to load audio track:', e);
        };

        const source = document.createElement('source');
        source.src = preparedUrl;
        audioTrackEl.appendChild(source);
        mediaWrapper.appendChild(audioTrackEl);

        // Sync playback with main video
        if (currentMediaEl?.tagName === 'VIDEO') {
          syncAudioWithVideo();
        }
      }

      function syncAudioWithVideo() {
        if (!audioTrackEl || !currentMediaEl || currentMediaEl.tagName !== 'VIDEO') return;

        const video = currentMediaEl;

        video.addEventListener('play', () => {
          if (audioTrackEl) {
            audioTrackEl.currentTime = video.currentTime;
            audioTrackEl.play().catch(() => {});
          }
        });

        video.addEventListener('pause', () => {
          if (audioTrackEl) audioTrackEl.pause();
        });

        video.addEventListener('seeked', () => {
          if (audioTrackEl) audioTrackEl.currentTime = video.currentTime;
        });

        video.addEventListener('ratechange', () => {
          if (audioTrackEl) audioTrackEl.playbackRate = video.playbackRate;
        });
      }

      async function loadMedia(settings) {
        showLoading();

        const source = await getMediaSource(settings);

        console.log('[MediaViewer] loadMedia called, source:', {
          type: source.type,
          urlLength: source.url?.length || 0,
          urlStart: source.url?.substring(0, 100) || 'null'
        });

        // If we're waiting for a file access response (FileReference)
        if (!source.url && source.type === 'file') {
          const rawValue = settings.mediaFile;

          // FileReference - waiting for user to approve
          if (isFileReference(rawValue)) {
            console.log('[MediaViewer] Waiting for file access approval:', rawValue.filename);
            showFallback('En attente d\'autorisation...');
            return;
          }

          // Legacy blob placeholder
          if (rawValue && typeof rawValue === 'string' && rawValue.startsWith('__blob_')) {
            console.log('[MediaViewer] Waiting for legacy blob to arrive:', rawValue);
            return;  // Will be called again when blob arrives
          }
        }

        if (!source.url) {
          const messages = {
            'file': 'No file uploaded',
            'url': 'No URL configured'
          };
          showFallback(messages[settings.sourceType] || 'No URL configured');
          return;
        }

        // Check if URL is truncated or empty
        if (source.url.length < 50 && source.url.startsWith('data:')) {
          console.error('[MediaViewer] Data URL appears truncated! Length:', source.url.length);
          showFallback('File data is corrupted or too large');
          return;
        }

        // Clear previous media
        if (currentMediaEl) {
          if (currentMediaEl.tagName === 'VIDEO' || currentMediaEl.tagName === 'AUDIO') {
            currentMediaEl.pause();
            currentMediaEl.src = '';
          }
          currentMediaEl.remove();
          currentMediaEl = null;
        }

        // Clear audio track
        if (audioTrackEl) {
          audioTrackEl.pause();
          audioTrackEl.src = '';
          audioTrackEl.remove();
          audioTrackEl = null;
        }

        // Prepare URL (convert data: to blob: for CSP compatibility)
        const mediaUrl = prepareMediaUrl(source.url);

        // For URL sources, try to detect embed platforms first
        if (source.type === 'url') {
          const embedData = parseEmbedUrl(source.url, settings);
          if (embedData) {
            console.log('[MediaViewer] Loading embed:', embedData.platform, embedData.videoId);
            currentMediaEl = createEmbedElement(embedData, settings);
            applyStyles(currentMediaEl, settings);
            applyContainerStyles(settings);
            mediaWrapper.appendChild(currentMediaEl);
            return;
          }
        }

        // Handle direct media (images, videos, audio, uploaded files)
        const mediaType = getMediaType(source.url);
        console.log('[MediaViewer] Loading media:', mediaUrl.substring(0, 50) + '...', 'type:', mediaType);

        if (mediaType === 'video') {
          currentMediaEl = createVideoElement(mediaUrl, settings);
          // Load audio track after video if enabled
          setTimeout(() => loadAudioTrack(settings), 100);
        } else if (mediaType === 'audio') {
          currentMediaEl = createAudioElement(mediaUrl, settings);
        } else if (mediaType === 'image') {
          currentMediaEl = createImageElement(mediaUrl, settings);
          // Load audio track for images too (background music)
          setTimeout(() => loadAudioTrack(settings), 100);
        } else if (mediaType === 'unknown') {
          // Try as image first, then video, then audio
          currentMediaEl = createImageElement(mediaUrl, settings);
          currentMediaEl.onerror = () => {
            console.log('[MediaViewer] Image failed, trying as video');
            currentMediaEl.remove();
            currentMediaEl = createVideoElement(mediaUrl, settings);
            currentMediaEl.onerror = () => {
              console.log('[MediaViewer] Video failed, trying as audio');
              currentMediaEl.remove();
              currentMediaEl = createAudioElement(mediaUrl, settings);
              applyStyles(currentMediaEl, settings);
              mediaWrapper.appendChild(currentMediaEl);
            };
            applyStyles(currentMediaEl, settings);
            mediaWrapper.appendChild(currentMediaEl);
          };
        } else {
          showFallback('Unsupported media type');
          return;
        }

        applyStyles(currentMediaEl, settings);
        applyContainerStyles(settings);
        mediaWrapper.appendChild(currentMediaEl);
      }

      function setupRefreshTimer(intervalMinutes) {
        if (refreshTimer) {
          clearInterval(refreshTimer);
          refreshTimer = null;
        }

        if (intervalMinutes > 0) {
          const intervalMs = intervalMinutes * 60 * 1000;
          refreshTimer = setInterval(() => {
            console.log('[MediaViewer] Auto-refreshing media');
            loadMedia(api.config);
          }, intervalMs);
        }
      }

      // ==========================================================================
      // EVENT HANDLERS
      // ==========================================================================

      api.onSettingsChange((settings, changedKeys) => {
        console.log('[MediaViewer] Settings changed:', changedKeys);

        // Check if media source changed
        const mediaChanged = changedKeys.includes('mediaUrl') ||
                            changedKeys.includes('mediaFile') ||
                            changedKeys.includes('sourceType');

        // Check if audio track settings changed
        const audioTrackChanged = changedKeys.includes('audioTrackEnabled') ||
                                  changedKeys.includes('audioTrackSourceType') ||
                                  changedKeys.includes('audioTrackUrl') ||
                                  changedKeys.includes('audioTrackFile');

        if (mediaChanged) {
          loadMedia(settings);
        } else {
          // Apply style changes without reloading
          applyStyles(currentMediaEl, settings);
          applyContainerStyles(settings);

          // Video/Audio-specific settings
          if (currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO') {
            applyVideoSettings(currentMediaEl, settings);
          }

          // Update audio track settings
          if (audioTrackEl) {
            applyAudioTrackSettings(audioTrackEl, settings);
          }
        }

        // Handle audio track changes
        if (audioTrackChanged && !mediaChanged) {
          loadAudioTrack(settings);
        }

        // Handle refresh interval change
        if (changedKeys.includes('refreshInterval')) {
          setupRefreshTimer(settings.refreshInterval);
        }

        // Update fallback text
        if (changedKeys.includes('fallbackText') && !fallbackEl.classList.contains('hidden')) {
          fallbackText.textContent = settings.fallbackText;
        }
      });

      api.onEvent('viewport:resize', ({ width, height }) => {
        console.log(`[MediaViewer] Viewport resized: ${width}x${height}`);
        // Media elements auto-resize via CSS, no action needed
      });

      api.onEvent('theme:change', ({ theme }) => {
        console.log(`[MediaViewer] Theme changed: ${theme}`);
        document.body.dataset.theme = theme;
      });

      api.onEvent('visibility:change', ({ visible }) => {
        console.log(`[MediaViewer] Visibility changed: ${visible}`);
        const isPlayableMedia = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';

        if (isPlayableMedia) {
          if (!visible && !currentMediaEl.paused) {
            currentMediaEl.pause();
            if (audioTrackEl) audioTrackEl.pause();
          } else if (visible && api.config.autoplay && !isPaused) {
            currentMediaEl.play().catch(() => {});
            if (audioTrackEl) audioTrackEl.play().catch(() => {});
          }
        }
      });

      api.onMount(() => {
        console.log('[MediaViewer] Mounted');
      });

      api.onUnmount(() => {
        console.log('[MediaViewer] Unmounting - cleaning up');
        if (refreshTimer) {
          clearInterval(refreshTimer);
        }
        if (currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO') {
          currentMediaEl.pause();
        }
        if (audioTrackEl) {
          audioTrackEl.pause();
        }
        // Clean up blob URLs to prevent memory leaks
        for (const blobUrl of blobUrlCache.values()) {
          URL.revokeObjectURL(blobUrl);
        }
        blobUrlCache.clear();
        // Clean up received blobs from host
        for (const blobUrl of receivedBlobs.values()) {
          URL.revokeObjectURL(blobUrl);
        }
        receivedBlobs.clear();
        // Clean up granted blob URLs from file access API (v2.6)
        for (const blobUrl of grantedBlobUrls.values()) {
          URL.revokeObjectURL(blobUrl);
        }
        grantedBlobUrls.clear();
      });

      api.onPause(() => {
        console.log('[MediaViewer] Paused');
        isPaused = true;
        const isPlayableMedia = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';
        if (isPlayableMedia && !currentMediaEl.paused) {
          currentMediaEl.pause();
        }
        if (audioTrackEl && !audioTrackEl.paused) {
          audioTrackEl.pause();
        }
      });

      api.onResume(() => {
        console.log('[MediaViewer] Resumed');
        isPaused = false;
        const isPlayableMedia = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';
        if (isPlayableMedia && api.config.autoplay) {
          currentMediaEl.play().catch(() => {});
        }
        if (audioTrackEl && api.config.autoplay) {
          audioTrackEl.play().catch(() => {});
        }
      });

      // ==========================================================================
      // INITIALIZATION
      // ==========================================================================

      function init() {
        console.log('[MediaViewer] Initializing...');

        // Apply initial settings
        loadMedia(api.config);
        setupRefreshTimer(api.config.refreshInterval);

        // Signal ready
        api.ready({
          capabilities: ['hot-reload'],
          subscribedEvents: ['viewport:resize', 'theme:change', 'visibility:change']
        });

        console.log('[MediaViewer] Ready! SDK v' + api.version);
      }

      init();

    })();
  </script>
</body>
</html>
