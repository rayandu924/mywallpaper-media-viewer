<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Media Viewer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: transparent; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }
    #container { width: 100%; height: 100%; position: relative; overflow: hidden; transition: background-color 0.3s ease, border-radius 0.3s ease; }
    #media-wrapper { width: 100%; height: 100%; overflow: hidden; position: relative; z-index: 1; }
    .media-element { width: 100%; height: 100%; display: block; transition: opacity 0.3s ease, filter 0.3s ease, border-radius 0.3s ease; }
    video::-webkit-media-controls { background: linear-gradient(transparent, rgba(0,0,0,0.5)); }
    video::-webkit-media-controls-panel { background: transparent; }
    .audio-element { max-width: 90%; max-height: 60px; border-radius: 8px; background: linear-gradient(135deg, rgba(30,30,46,0.9) 0%, rgba(20,20,30,0.95) 100%); }
    audio::-webkit-media-controls-panel { background: linear-gradient(to right, rgba(60,60,80,0.95), rgba(40,40,60,0.95)); }
    audio::-webkit-media-controls-current-time-display, audio::-webkit-media-controls-time-remaining-display { color: rgba(255,255,255,0.9); }
    .audio-track-element { display: none !important; position: absolute; pointer-events: none; }
    .embed-frame { width: 100%; height: 100%; border: none; background: #000; }
    #fallback { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: linear-gradient(135deg, rgba(30,30,46,0.9) 0%, rgba(20,20,30,0.95) 100%); color: rgba(255,255,255,0.6); text-align: center; padding: 20px; transition: opacity 0.3s ease; }
    .fallback-icon { width: 64px; height: 64px; margin-bottom: 16px; opacity: 0.4; }
    .fallback-icon svg { width: 100%; height: 100%; stroke: currentColor; }
    #fallback-text { font-size: 14px; font-weight: 500; max-width: 200px; line-height: 1.4; }
    #loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); }
    .spinner { width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.2); border-top-color: rgba(255,255,255,0.8); border-radius: 50%; animation: spin 0.8s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .hidden { display: none !important; }
    [data-theme="light"] #fallback { background: linear-gradient(135deg, rgba(240,240,245,0.95) 0%, rgba(220,220,230,0.98) 100%); color: rgba(0,0,0,0.5); }
    [data-theme="light"] #loading { background: rgba(255,255,255,0.5); }
    [data-theme="light"] .spinner { border-color: rgba(0,0,0,0.1); border-top-color: rgba(0,0,0,0.6); }
    @media (max-width: 150px), (max-height: 150px) { .fallback-icon { width: 32px; height: 32px; margin-bottom: 8px; } #fallback-text { font-size: 10px; } .spinner { width: 24px; height: 24px; border-width: 2px; } }
    @media (max-width: 100px), (max-height: 100px) { #fallback-text { display: none; } .fallback-icon { margin-bottom: 0; } }
    @media print { body { display: none; } }
  </style>
</head>
<body>
  <div id="container">
    <div id="media-wrapper">
      <!-- Dynamic media element will be inserted here -->
    </div>
    <div id="fallback" class="hidden">
      <div class="fallback-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
          <circle cx="8.5" cy="8.5" r="1.5"/>
          <polyline points="21,15 16,10 5,21"/>
        </svg>
      </div>
      <p id="fallback-text">Media unavailable</p>
    </div>
    <div id="loading" class="hidden">
      <div class="spinner"></div>
    </div>
  </div>

  <script>
    // ==========================================================================
    // Media Viewer Addon - MyWallpaper SDK v2.17.1
    // ==========================================================================
    // Supports: Images (jpg, png, gif, webp, svg, ico, bmp, avif)
    //           Videos (mp4, webm, ogg, mov)
    //           Audio  (mp3, wav, ogg, flac, aac, m4a, opus, weba)
    //           External URLs and uploaded files
    //           Video platforms (YouTube, Vimeo, Twitch, Dailymotion)
    //
    // File access via SDK api.files API (FileReference handling)
    // Audio playback via parent-managed api.audio (sandbox restrictions)
    // ==========================================================================

    (function() {
      'use strict';

      // Get API reference (may be injected later)
      let api = window.MyWallpaper;

      // DOM Elements
      const container = document.getElementById('container');
      const mediaWrapper = document.getElementById('media-wrapper');
      const fallbackEl = document.getElementById('fallback');
      const fallbackText = document.getElementById('fallback-text');
      const loadingEl = document.getElementById('loading');

      // State
      let currentMediaEl = null;
      let refreshTimer = null;
      let isPaused = false;
      let audioUnsubscribe = null;
      let usingParentAudio = false;

      /**
       * Resolve a setting value to a usable URL with mimeType
       * Handles: FileReference (via SDK api.files) and direct URLs
       * Returns: { url: string, mimeType: string } or null
       */
      async function resolveSettingValue(value, settingKey) {
        // FileReference → SDK file access API
        if (api.files && api.files.isFileReference(value)) {
          const result = await api.files.request(settingKey);
          if (result && result.granted && result.blobUrl) {
            return { url: result.blobUrl, mimeType: '' };
          }
          return null;
        }

        // Direct URL/data URL
        if (typeof value === 'string' && value.length > 0) {
          let mimeType = '';
          if (value.startsWith('data:')) {
            const match = value.match(/^data:([^;,]+)/);
            if (match) mimeType = match[1];
          }
          return { url: value, mimeType };
        }

        return null;
      }

      // Media type detection
      const VIDEO_EXTENSIONS = ['mp4', 'webm', 'ogg', 'mov', 'm4v', 'avi', 'mkv'];
      const IMAGE_EXTENSIONS = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'ico', 'bmp', 'avif', 'tiff'];
      const AUDIO_EXTENSIONS = ['mp3', 'wav', 'ogg', 'flac', 'aac', 'm4a', 'opus', 'weba', 'wma'];

      // Embed platforms configuration
      const EMBED_PLATFORMS = {
        youtube: {
          patterns: [
            /youtube\.com\/watch\?v=([^&]+)/,
            /youtube\.com\/embed\/([^?]+)/,
            /youtu\.be\/([^?]+)/,
            /youtube\.com\/shorts\/([^?]+)/
          ],
          embedUrl: (id, opts) => {
            const params = new URLSearchParams({
              autoplay: opts.autoplay ? '1' : '0',
              mute: opts.muted ? '1' : '0',
              loop: opts.loop ? '1' : '0',
              rel: '0',
              modestbranding: '1',
              playsinline: '1',
              enablejsapi: '0',
              origin: window.location.origin
            });
            return `https://www.youtube.com/embed/${id}?${params.toString()}`;
          }
        },
        vimeo: {
          patterns: [/vimeo\.com\/(\d+)/],
          embedUrl: (id, opts) =>
            `https://player.vimeo.com/video/${id}?autoplay=${opts.autoplay ? 1 : 0}&muted=${opts.muted ? 1 : 0}&loop=${opts.loop ? 1 : 0}&background=1`
        },
        twitch: {
          patterns: [
            /twitch\.tv\/videos\/(\d+)/,
            /twitch\.tv\/([^/?]+)$/
          ],
          embedUrl: (id, opts, isVideo) => {
            const parent = location.hostname || 'localhost';
            return isVideo
              ? `https://player.twitch.tv/?video=${id}&parent=${parent}&autoplay=${opts.autoplay}`
              : `https://player.twitch.tv/?channel=${id}&parent=${parent}&autoplay=${opts.autoplay}&muted=${opts.muted}`;
          }
        },
        dailymotion: {
          patterns: [/dailymotion\.com\/video\/([^_?]+)/],
          embedUrl: (id, opts) =>
            `https://www.dailymotion.com/embed/video/${id}?autoplay=${opts.autoplay ? 1 : 0}&mute=${opts.muted ? 1 : 0}`
        }
      };

      // ==========================================================================
      // UTILITY FUNCTIONS
      // ==========================================================================

      function getMediaType(url, mimeType = '') {
        if (!url) return null;

        if (mimeType) {
          if (mimeType.startsWith('video/')) return 'video';
          if (mimeType.startsWith('image/')) return 'image';
          if (mimeType.startsWith('audio/')) return 'audio';
        }

        if (url.startsWith('data:')) {
          if (url.startsWith('data:video/')) return 'video';
          if (url.startsWith('data:image/')) return 'image';
          if (url.startsWith('data:audio/')) return 'audio';
          return null;
        }

        if (url.startsWith('blob:')) return 'unknown';

        try {
          const urlObj = new URL(url);
          const pathname = urlObj.pathname.toLowerCase();
          const extension = pathname.split('.').pop();

          if (VIDEO_EXTENSIONS.includes(extension)) return 'video';
          if (IMAGE_EXTENSIONS.includes(extension)) return 'image';
          if (AUDIO_EXTENSIONS.includes(extension)) return 'audio';
        } catch (e) {
          const extension = url.split('.').pop()?.toLowerCase().split('?')[0];
          if (VIDEO_EXTENSIONS.includes(extension)) return 'video';
          if (IMAGE_EXTENSIONS.includes(extension)) return 'image';
          if (AUDIO_EXTENSIONS.includes(extension)) return 'audio';
        }

        if (url.includes('youtube.com') || url.includes('youtu.be') ||
            url.includes('vimeo.com') || url.includes('dailymotion.com')) {
          return null;
        }

        return 'unknown';
      }

      function buildFilterString(settings) {
        const filters = [];
        if (settings.blur > 0) filters.push(`blur(${settings.blur}px)`);
        if (settings.brightness !== 100) filters.push(`brightness(${settings.brightness}%)`);
        if (settings.contrast !== 100) filters.push(`contrast(${settings.contrast}%)`);
        if (settings.saturate !== 100) filters.push(`saturate(${settings.saturate}%)`);
        if (settings.hueRotate > 0) filters.push(`hue-rotate(${settings.hueRotate}deg)`);
        return filters.length > 0 ? filters.join(' ') : 'none';
      }

      function parseEmbedUrl(url, settings) {
        if (!url) return null;

        const opts = {
          autoplay: settings.autoplay ?? true,
          muted: settings.muted ?? true,
          loop: settings.loop ?? false
        };

        for (const [platform, config] of Object.entries(EMBED_PLATFORMS)) {
          for (const pattern of config.patterns) {
            const match = url.match(pattern);
            if (match) {
              const id = match[1];
              const isVideo = platform === 'twitch' && url.includes('/videos/');
              return {
                platform,
                embedUrl: config.embedUrl(id, opts, isVideo),
                videoId: id
              };
            }
          }
        }

        return null;
      }

      // ==========================================================================
      // UI HELPERS
      // ==========================================================================

      function showLoading() {
        loadingEl.classList.remove('hidden');
        fallbackEl.classList.add('hidden');
      }

      function hideLoading() {
        loadingEl.classList.add('hidden');
      }

      function showFallback(message) {
        hideLoading();
        fallbackText.textContent = message || api.config.fallbackText || 'Media unavailable';
        fallbackEl.classList.remove('hidden');
        if (currentMediaEl) {
          currentMediaEl.classList.add('hidden');
        }
      }

      function hideFallback() {
        fallbackEl.classList.add('hidden');
      }

      // ==========================================================================
      // MEDIA CREATION
      // Each function returns { element, ready: Promise<void> }
      // They NEVER call renderComplete, showFallback, hideLoading, etc.
      // ==========================================================================

      function createImageElement(url) {
        const img = document.createElement('img');
        img.className = 'media-element';
        img.alt = 'Media content';
        img.draggable = false;
        img.src = url;

        // Cached images — no Promise overhead
        if (img.complete && img.naturalWidth > 0) {
          return { element: img, ready: Promise.resolve() };
        }

        const ready = new Promise((resolve, reject) => {
          img.onload = () => resolve();
          img.onerror = () => reject(new Error('Failed to load image'));
        });

        return { element: img, ready };
      }

      function createVideoElement(url, settings, mimeType = '') {
        const video = document.createElement('video');
        video.className = 'media-element';
        video.autoplay = settings.autoplay && !isPaused;
        video.loop = settings.loop;
        video.muted = true;   // Always muted in iframe — audio via parent
        video.volume = 1;
        video.controls = settings.showControls;
        video.playbackRate = settings.playbackRate;
        video.playsInline = true;
        video.preload = 'auto';

        const ready = new Promise((resolve, reject) => {
          const loadTimeout = setTimeout(() => {
            console.warn('[MediaViewer] Video load timeout (8s)');
            resolve();
          }, 8000);

          video.onloadeddata = () => {
            clearTimeout(loadTimeout);
            resolve();
          };

          video.onerror = () => {
            clearTimeout(loadTimeout);
            if (video.readyState > 0 || video.networkState === 2) return;
            reject(new Error(`Video error: ${video.error?.code} ${video.error?.message}`));
          };
        });

        // Audio sync handlers (behavioral, independent of loading)
        video.onplay = () => { if (usingParentAudio) api.audio.resume(); };
        video.onpause = () => { if (usingParentAudio && !video.ended) api.audio.pause(); };
        video.onseeked = () => { if (usingParentAudio) api.audio.seek(video.currentTime); };
        video.onended = () => { if (usingParentAudio && !settings.loop) api.audio.stop(); };

        if (url.startsWith('data:') || url.startsWith('blob:')) {
          video.src = url;
        } else {
          const source = document.createElement('source');
          source.src = url;
          let detectedMimeType = mimeType;
          if (!detectedMimeType) {
            const ext = url.split('.').pop()?.toLowerCase().split('?')[0];
            const mimeTypes = { mp4: 'video/mp4', webm: 'video/webm', ogg: 'video/ogg', mov: 'video/quicktime', m4v: 'video/mp4' };
            detectedMimeType = mimeTypes[ext] || '';
          }
          if (detectedMimeType) source.type = detectedMimeType;
          video.appendChild(source);
        }

        return { element: video, ready };
      }

      function createAudioElement(url, settings, mimeType = '') {
        const audio = document.createElement('audio');
        audio.className = 'media-element audio-element';
        audio.autoplay = settings.autoplay && !isPaused;
        audio.loop = settings.loop;
        audio.muted = settings.muted;
        audio.volume = (settings.volume ?? 80) / 100;
        audio.controls = settings.showControls ?? true;
        audio.playbackRate = settings.playbackRate ?? 1;
        audio.preload = 'auto';

        const ready = new Promise((resolve, reject) => {
          audio.onloadeddata = () => resolve();
          audio.onerror = () => reject(new Error(`Audio error: ${audio.error?.code} ${audio.error?.message}`));
        });

        if (url.startsWith('data:') || url.startsWith('blob:')) {
          audio.src = url;
        } else {
          const source = document.createElement('source');
          source.src = url;
          let detectedMimeType = mimeType;
          if (!detectedMimeType) {
            const ext = url.split('.').pop()?.toLowerCase().split('?')[0];
            const mimeTypes = { mp3: 'audio/mpeg', wav: 'audio/wav', ogg: 'audio/ogg', flac: 'audio/flac', aac: 'audio/aac', m4a: 'audio/mp4', opus: 'audio/opus', weba: 'audio/webm', wma: 'audio/x-ms-wma' };
            detectedMimeType = mimeTypes[ext] || '';
          }
          if (detectedMimeType) source.type = detectedMimeType;
          audio.appendChild(source);
        }

        return { element: audio, ready };
      }

      function createEmbedElement(embedData) {
        const iframe = document.createElement('iframe');
        iframe.className = 'media-element embed-frame';
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
        iframe.allowFullscreen = true;
        iframe.setAttribute('referrerpolicy', 'no-referrer-when-downgrade');

        const ready = new Promise((resolve, reject) => {
          const fallbackTimeout = setTimeout(() => resolve(), 3000);
          iframe.onload = () => {
            clearTimeout(fallbackTimeout);
            resolve();
          };
          iframe.onerror = () => {
            clearTimeout(fallbackTimeout);
            reject(new Error(`Failed to load ${embedData.platform} embed`));
          };
        });

        iframe.src = embedData.embedUrl;

        return { element: iframe, ready };
      }

      function createMediaByType(type, url, settings, mimeType) {
        switch (type) {
          case 'image': return createImageElement(url);
          case 'video': return createVideoElement(url, settings, mimeType);
          case 'audio': return createAudioElement(url, settings, mimeType);
          default: return null;
        }
      }

      // ==========================================================================
      // CLEANUP & AUDIO MANAGEMENT
      // ==========================================================================

      function cleanupCurrentMedia() {
        if (!currentMediaEl) return;
        if (currentMediaEl.tagName === 'VIDEO' || currentMediaEl.tagName === 'AUDIO') {
          currentMediaEl.pause();
          currentMediaEl.onerror = null;
          currentMediaEl.onloadeddata = null;
        }
        currentMediaEl.remove();
        currentMediaEl = null;
      }

      function startParentAudio(settings) {
        usingParentAudio = true;

        if (audioUnsubscribe) {
          audioUnsubscribe();
          audioUnsubscribe = null;
        }

        const source = settings.sourceType === 'file' ? 'mediaFile' : settings.mediaUrl;

        api.audio.play(source, {
          volume: (settings.volume ?? 80) / 100,
          loop: settings.loop,
          playbackRate: settings.playbackRate,
          startTime: currentMediaEl?.currentTime || 0
        });

        audioUnsubscribe = api.audio.onStateChange((state) => {
          if (!currentMediaEl || currentMediaEl.tagName !== 'VIDEO') return;
          if (state.status === 'playing') {
            const drift = Math.abs(currentMediaEl.currentTime - state.currentTime);
            if (drift > 0.3) currentMediaEl.currentTime = state.currentTime;
          }
        });
      }

      function stopParentAudio() {
        if (!usingParentAudio) return;
        api.audio.stop();
        usingParentAudio = false;
        if (audioUnsubscribe) {
          audioUnsubscribe();
          audioUnsubscribe = null;
        }
      }

      // ==========================================================================
      // APPLY SETTINGS
      // ==========================================================================

      function applyStyles(element, settings) {
        if (!element) return;

        element.style.objectFit = settings.objectFit || 'contain';
        element.style.objectPosition = settings.objectPosition || 'center';
        element.style.opacity = (settings.opacity ?? 100) / 100;
        element.style.filter = buildFilterString(settings);
        element.style.borderRadius = `${settings.borderRadius || 0}px`;
      }

      function applyContainerStyles(settings) {
        container.style.backgroundColor = settings.backgroundColor || 'transparent';
        container.style.borderRadius = `${settings.borderRadius || 0}px`;
      }

      function applyVideoSettings(video, settings) {
        if (!video || video.tagName !== 'VIDEO') return;

        video.loop = settings.loop;
        video.controls = settings.showControls;

        if (video.playbackRate !== settings.playbackRate) {
          video.playbackRate = settings.playbackRate;
        }

        if (!settings.muted && !usingParentAudio) {
          startParentAudio(settings);
        } else if (settings.muted && usingParentAudio) {
          stopParentAudio();
        }

        if (usingParentAudio) {
          api.audio.setVolume((settings.volume ?? 80) / 100);
          api.audio.setLoop(settings.loop);
          api.audio.setPlaybackRate(settings.playbackRate);
        }

        if (settings.autoplay && video.paused && !isPaused) {
          video.play().catch(() => {});
        } else if (!settings.autoplay && !video.paused) {
          video.pause();
        }
      }

      function applyAudioElementSettings(audio, settings) {
        if (!audio || audio.tagName !== 'AUDIO') return;

        audio.loop = settings.loop;
        audio.controls = settings.showControls ?? true;

        if (settings.autoplay && audio.paused && !isPaused) {
          audio.play().catch(() => {});
        } else if (!settings.autoplay && !audio.paused) {
          audio.pause();
        }
      }

      // ==========================================================================
      // MEDIA LOADING
      // ==========================================================================

      async function getMediaSource(settings) {
        switch (settings.sourceType) {
          case 'file':
            const fileResult = await resolveSettingValue(settings.mediaFile, 'mediaFile');
            if (fileResult) return { type: 'file', url: fileResult.url, mimeType: fileResult.mimeType };
            return { type: 'file', url: null, mimeType: '' };
          case 'url':
          default:
            const urlResult = await resolveSettingValue(settings.mediaUrl, 'mediaUrl');
            if (urlResult) return { type: 'url', url: urlResult.url, mimeType: urlResult.mimeType };
            return { type: 'url', url: settings.mediaUrl || null, mimeType: '' };
        }
      }

      let loadMediaVersion = 0;

      /**
       * Wait for next animation frame to ensure element is painted
       */
      function waitForPaint() {
        return new Promise(resolve => requestAnimationFrame(resolve));
      }

      /**
       * Mount a loaded element into the DOM and signal render complete.
       * Single exit point for successful media display.
       */
      async function mountMedia(element, settings, thisVersion) {
        currentMediaEl = element;
        applyStyles(element, settings);
        mediaWrapper.appendChild(element);

        hideLoading();
        hideFallback();

        if (element.tagName === 'VIDEO' && !settings.muted) {
          startParentAudio(settings);
        }

        await waitForPaint();
        if (thisVersion !== loadMediaVersion) return;
        api.renderComplete();
      }

      /**
       * Main loading function — single point of renderComplete emission.
       * Direct media: create off-DOM → await ready → mount → paint → renderComplete
       * Embeds:       create → mount (needed to load) → await ready → paint → renderComplete
       */
      async function loadMedia(settings) {
        const thisVersion = ++loadMediaVersion;

        showLoading();

        const source = await getMediaSource(settings);
        if (thisVersion !== loadMediaVersion) return;

        // Network permission for external URLs
        if (source.type === 'url' && source.url && !source.url.startsWith('data:') && !source.url.startsWith('blob:')) {
          try {
            const domain = new URL(source.url).hostname;
            if (api.network && api.network.requestAccess) {
              const accessResult = await api.network.requestAccess(domain, `Load media from ${domain}`);
              if (!accessResult.granted) {
                showFallback('Network access denied');
                api.renderComplete();
                return;
              }
            }
          } catch (e) { /* invalid URL, continue */ }
        }

        if (!source.url) {
          const messages = { file: 'No file uploaded', url: 'No URL configured' };
          showFallback(messages[settings.sourceType] || 'No URL configured');
          api.renderComplete();
          return;
        }

        if (source.url.length < 50 && source.url.startsWith('data:')) {
          showFallback('File data is corrupted or too large');
          api.renderComplete();
          return;
        }

        cleanupCurrentMedia();
        applyContainerStyles(settings);

        // --- Embed platforms (URL sources only) ---
        // Iframes MUST be in the DOM to start loading
        if (source.type === 'url') {
          const embedData = parseEmbedUrl(source.url, settings);
          if (embedData) {
            const { element, ready } = createEmbedElement(embedData);
            currentMediaEl = element;
            applyStyles(element, settings);
            mediaWrapper.appendChild(element);

            try {
              await ready;
              if (thisVersion !== loadMediaVersion) return;
              hideLoading();
              hideFallback();
            } catch (e) {
              if (thisVersion !== loadMediaVersion) return;
              console.error('[MediaViewer]', e.message);
              showFallback(`Failed to load ${embedData.platform} video`);
            }

            await waitForPaint();
            api.renderComplete();
            return;
          }
        }

        // --- Direct media ---
        // Elements load via src without DOM insertion.
        // Probe off-DOM, mount only the successful element → zero DOM thrash on failure.
        const mediaType = getMediaType(source.url, source.mimeType);
        const typesToTry = mediaType === 'unknown'
          ? ['image', 'video', 'audio']
          : mediaType ? [mediaType] : [];

        if (typesToTry.length === 0) {
          showFallback('Unsupported media type');
          api.renderComplete();
          return;
        }

        for (const type of typesToTry) {
          const result = createMediaByType(type, source.url, settings, source.mimeType);
          if (!result) continue;

          try {
            await result.ready;
            if (thisVersion !== loadMediaVersion) return;
            await mountMedia(result.element, settings, thisVersion);
            return;
          } catch (e) {
            if (thisVersion !== loadMediaVersion) return;
            console.log(`[MediaViewer] ${type} failed:`, e.message);
          }
        }

        showFallback(settings.fallbackText);
        api.renderComplete();
      }

      function setupRefreshTimer(intervalMinutes) {
        if (refreshTimer) {
          clearInterval(refreshTimer);
          refreshTimer = null;
        }

        if (intervalMinutes > 0) {
          const intervalMs = intervalMinutes * 60 * 1000;
          refreshTimer = setInterval(() => loadMedia(api.config), intervalMs);
        }
      }

      // ==========================================================================
      // EVENT HANDLERS
      // ==========================================================================

      api.onSettingsChange((settings, changedKeys) => {
        const mediaChanged = changedKeys.includes('mediaUrl') ||
                            changedKeys.includes('mediaFile') ||
                            changedKeys.includes('sourceType');

        if (mediaChanged) {
          stopParentAudio();
          loadMedia(settings);
        } else {
          applyStyles(currentMediaEl, settings);
          applyContainerStyles(settings);

          if (currentMediaEl?.tagName === 'VIDEO') {
            applyVideoSettings(currentMediaEl, settings);
          } else if (currentMediaEl?.tagName === 'AUDIO') {
            applyAudioElementSettings(currentMediaEl, settings);
          }
        }

        if (changedKeys.includes('refreshInterval')) {
          setupRefreshTimer(settings.refreshInterval);
        }

        if (changedKeys.includes('fallbackText') && !fallbackEl.classList.contains('hidden')) {
          fallbackText.textContent = settings.fallbackText;
        }
      });

      api.onEvent('viewport:resize', () => {});

      api.onEvent('theme:change', ({ theme }) => {
        document.body.dataset.theme = theme;
      });

      api.onEvent('visibility:change', ({ visible }) => {
        const isPlayable = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';
        if (!isPlayable) return;

        if (!visible && !currentMediaEl.paused) {
          currentMediaEl.pause();
          if (usingParentAudio) api.audio.pause();
        } else if (visible && api.config.autoplay && !isPaused) {
          currentMediaEl.play().catch(() => {});
          if (usingParentAudio) api.audio.resume();
        }
      });

      api.onUnmount(() => {
        if (refreshTimer) clearInterval(refreshTimer);
        stopParentAudio();
        if (currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO') {
          currentMediaEl.pause();
        }
        if (api.files) api.files.revoke('mediaFile');
      });

      api.onPause(() => {
        isPaused = true;
        const isPlayable = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';
        if (isPlayable && !currentMediaEl.paused) {
          currentMediaEl.pause();
        }
        if (usingParentAudio) api.audio.pause();
      });

      api.onResume(() => {
        isPaused = false;
        const isPlayable = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';
        if (isPlayable && api.config.autoplay) {
          currentMediaEl.play().catch(() => {});
        }
        if (usingParentAudio) api.audio.resume();
      });

      // ==========================================================================
      // INITIALIZATION
      // ==========================================================================

      async function init() {
        api = window.MyWallpaper;

        if (!api) {
          console.error('[MediaViewer] SDK not available!');
          return;
        }

        try {
          await loadMedia(api.config || {});
          setupRefreshTimer((api.config || {}).refreshInterval);
        } catch (e) {
          console.error('[MediaViewer] Init error:', e);
          api.renderComplete();
        }

        api.ready({
          capabilities: ['hot-reload'],
          subscribedEvents: ['viewport:resize', 'theme:change', 'visibility:change']
        });
      }

      if (window.MyWallpaper) {
        init();
      } else {
        window.addEventListener('mywallpaper:ready', init);
      }

    })();
  </script>
</body>
</html>
