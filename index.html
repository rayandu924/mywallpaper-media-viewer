<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Media Viewer</title>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="container">
    <div id="media-wrapper">
      <!-- Dynamic media element will be inserted here -->
    </div>
    <div id="fallback" class="hidden">
      <div class="fallback-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
          <circle cx="8.5" cy="8.5" r="1.5"/>
          <polyline points="21,15 16,10 5,21"/>
        </svg>
      </div>
      <p id="fallback-text">Media unavailable</p>
    </div>
    <div id="loading" class="hidden">
      <div class="spinner"></div>
    </div>
  </div>

  <script>
    // ==========================================================================
    // Media Viewer Addon - MyWallpaper SDK v2.7
    // ==========================================================================
    // Supports: Images (jpg, png, gif, webp, svg, ico, bmp, avif)
    //           Videos (mp4, webm, ogg, mov)
    //           Audio  (mp3, wav, ogg, flac, aac, m4a, opus, weba)
    //           External URLs and uploaded files
    //           Video platforms (YouTube, Vimeo, Twitch, Dailymotion)
    //
    // AUDIO PLAYBACK: Uses parent-managed audio API (api.audio) for video sound
    // because sandboxed iframes cannot autoplay audio (browser security policy).
    // ==========================================================================

    (function() {
      'use strict';

      // Get API reference (may be injected later)
      let api = window.MyWallpaper;

      // DOM Elements
      const container = document.getElementById('container');
      const mediaWrapper = document.getElementById('media-wrapper');
      const fallbackEl = document.getElementById('fallback');
      const fallbackText = document.getElementById('fallback-text');
      const loadingEl = document.getElementById('loading');

      // State
      let currentMediaEl = null;
      let refreshTimer = null;
      let isPaused = false;
      let audioUnsubscribe = null;  // Unsubscribe function for audio state listener
      let usingParentAudio = false; // Whether we're using parent-managed audio

      // ==========================================================================
      // FILE ACCESS SUPPORT (NEW v2.6 API)
      // ==========================================================================
      // Files are now sent as FileReference objects instead of data URLs.
      // We must request access via api.files.request() which shows a user modal.

      // Cache of granted blob data (settingKey -> { blobUrl, mimeType, fileId })
      const grantedBlobUrls = new Map();

      // Pending file access requests (settingKey -> Promise)
      const pendingRequests = new Map();

      /**
       * Check if a value is a FileReference (new v2.6 format)
       */
      function isFileReference(value) {
        return value && typeof value === 'object' && value.__type === 'file-reference';
      }

      /**
       * Get a unique identifier for a FileReference
       */
      function getFileRefId(fileRef) {
        // Use id if available, otherwise fall back to filename + size
        return fileRef.id || `${fileRef.filename}-${fileRef.size || 0}`;
      }

      /**
       * Request file access and get blob URL
       * Returns null if denied or not yet granted
       *
       * The host sends the Blob object itself (not a blob URL) because:
       * - This iframe runs in about:srcdoc origin (null/opaque)
       * - Blob URLs are origin-scoped and cannot be accessed cross-origin
       * - We receive the Blob via structured clone algorithm
       * - We create our own blob URL in our own context
       */
      async function requestFileAccess(settingKey, fileRef) {
        const newFileId = getFileRefId(fileRef);

        // Check if we have a cached entry for this setting
        if (grantedBlobUrls.has(settingKey)) {
          const cached = grantedBlobUrls.get(settingKey);

          // If it's the same file, return cached blob URL
          if (cached.fileId === newFileId) {
            console.log(`[MediaViewer] Using cached blob URL for ${settingKey} (same file)`);
            return { blobUrl: cached.blobUrl, mimeType: cached.mimeType };
          }

          // Different file - revoke old blob URL and clear cache
          console.log(`[MediaViewer] File changed for ${settingKey}, revoking old blob URL`);
          URL.revokeObjectURL(cached.blobUrl);
          grantedBlobUrls.delete(settingKey);
        }

        // Already requesting?
        if (pendingRequests.has(settingKey)) {
          return pendingRequests.get(settingKey);
        }

        console.log(`[MediaViewer] Requesting file access for ${settingKey}: ${fileRef.filename}`);

        // Create promise for this request
        const requestPromise = new Promise((resolve) => {
          // Listen for FILE_ACCESS_RESPONSE
          const handler = (event) => {
            // Debug: log all messages from host
            if (event.data?.source === 'MyWallpaperHost') {
              console.log('[MediaViewer] Received message from host:', event.data.type, event.data);
            }

            if (event.data?.type === 'FILE_ACCESS_RESPONSE' &&
                event.data?.source === 'MyWallpaperHost' &&
                event.data?.settingKey === settingKey) {

              window.removeEventListener('message', handler);
              pendingRequests.delete(settingKey);

              console.log('[MediaViewer] FILE_ACCESS_RESPONSE received:', {
                granted: event.data.granted,
                hasBlob: !!event.data.blob,
                blobType: event.data.blob ? event.data.blob.constructor.name : 'N/A',
                isBlob: event.data.blob instanceof Blob,
                mimeType: event.data.mimeType,
                size: event.data.size
              });

              if (event.data.granted && event.data.blob instanceof Blob) {
                // Create our own blob URL from the received Blob
                const blobUrl = URL.createObjectURL(event.data.blob);
                const mimeType = event.data.mimeType || event.data.blob.type || '';
                console.log(`[MediaViewer] File access granted for ${settingKey}, created blob URL: ${blobUrl.substring(0, 50)}..., mimeType: ${mimeType}`);
                grantedBlobUrls.set(settingKey, { blobUrl, mimeType, fileId: newFileId });
                resolve({ blobUrl, mimeType });
                // Note: Don't call loadMedia here - the caller is awaiting the promise and will continue
              } else if (event.data.granted && event.data.blob) {
                // Blob might not be detected as instanceof Blob in sandboxed context
                // Try to create blob URL anyway
                console.log('[MediaViewer] Blob not detected as instanceof Blob, trying anyway...');
                try {
                  const blobUrl = URL.createObjectURL(event.data.blob);
                  const mimeType = event.data.mimeType || '';
                  console.log(`[MediaViewer] Successfully created blob URL: ${blobUrl.substring(0, 50)}..., mimeType: ${mimeType}`);
                  grantedBlobUrls.set(settingKey, { blobUrl, mimeType, fileId: newFileId });
                  resolve({ blobUrl, mimeType });
                  // Note: Don't call loadMedia here - the caller is awaiting the promise and will continue
                } catch (e) {
                  console.error('[MediaViewer] Failed to create blob URL:', e);
                  resolve(null);
                }
              } else {
                console.log(`[MediaViewer] File access denied for ${settingKey}`);
                resolve(null);
              }
            }
          };

          window.addEventListener('message', handler);

          // Send request to host
          window.parent.postMessage({
            type: 'FILE_ACCESS_REQUEST',
            layerId: api.layerId,
            settingKey: settingKey,
            requestId: `${settingKey}-${Date.now()}`
          }, '*');
        });

        pendingRequests.set(settingKey, requestPromise);
        return requestPromise;
      }

      // ==========================================================================
      // LEGACY BLOB TRANSFER SUPPORT (for backwards compatibility)
      // ==========================================================================
      // Keep support for old FILE_BLOB messages in case host hasn't updated

      const receivedBlobs = new Map();  // Map<placeholderId, blobUrl>

      window.addEventListener('message', (event) => {
        // Legacy FILE_BLOB support
        if (event.data?.type === 'FILE_BLOB' && event.data?.source === 'MyWallpaperHost') {
          const { settingKey, placeholderId, blob, mimeType } = event.data;

          if (blob && blob instanceof Blob) {
            const blobUrl = URL.createObjectURL(blob);
            receivedBlobs.set(placeholderId, blobUrl);
            console.log(`[MediaViewer] Received legacy blob for ${settingKey}: ${blobUrl.substring(0, 50)}... (${blob.size} bytes, ${mimeType})`);

            if (api.config) {
              const needsReload = api.config.mediaFile === placeholderId;

              if (needsReload) {
                console.log('[MediaViewer] Blob received for pending media, reloading...');
                loadMedia(api.config);
              }
            }
          }
        }
      });

      /**
       * Resolve a setting value to a usable URL with mimeType
       * Handles: FileReference, blob placeholders, and direct URLs
       * Returns: { url: string, mimeType: string } or null
       */
      async function resolveSettingValue(value, settingKey) {
        // NEW: FileReference object (v2.6)
        if (isFileReference(value)) {
          const result = await requestFileAccess(settingKey, value);
          if (result && result.blobUrl) {
            return { url: result.blobUrl, mimeType: result.mimeType || '' };
          }
          return null;
        }

        // Legacy: blob placeholder string
        if (typeof value === 'string' && value.startsWith('__blob_')) {
          const blobUrl = receivedBlobs.get(value);
          if (blobUrl) {
            console.log('[MediaViewer] Resolved legacy placeholder to blob URL');
            return { url: blobUrl, mimeType: '' };
          }
          console.log('[MediaViewer] Waiting for legacy blob:', value);
          return null;
        }

        // Direct URL/data URL - extract mimeType from data URL if possible
        if (typeof value === 'string') {
          let mimeType = '';
          if (value.startsWith('data:')) {
            const match = value.match(/^data:([^;,]+)/);
            if (match) mimeType = match[1];
          }
          return { url: value, mimeType };
        }

        return null;
      }

      // Media type detection
      const VIDEO_EXTENSIONS = ['mp4', 'webm', 'ogg', 'mov', 'm4v', 'avi', 'mkv'];
      const IMAGE_EXTENSIONS = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'ico', 'bmp', 'avif', 'tiff'];
      const AUDIO_EXTENSIONS = ['mp3', 'wav', 'ogg', 'flac', 'aac', 'm4a', 'opus', 'weba', 'wma'];

      // Cache for converted blob URLs to avoid memory leaks
      const blobUrlCache = new Map();

      /**
       * Check if we're in a sandboxed context where blob URLs won't work
       * In srcdoc iframes WITHOUT allow-same-origin, the origin is "null" and blob:null/... URLs fail
       */
      function isNullOrigin() {
        try {
          // If we can access window.origin and it's not 'null', we have same-origin
          return window.origin === 'null' || window.location.origin === 'null';
        } catch (e) {
          // If we can't access, assume null origin
          return true;
        }
      }

      /**
       * Convert data URL to Blob URL to bypass CSP restrictions
       * CSP often allows blob: but blocks data: for media-src
       * With allow-same-origin, blob URLs work properly
       */
      function dataUrlToBlobUrl(dataUrl) {
        // Check if we're in null-origin context
        const nullOrigin = isNullOrigin();
        console.log('[MediaViewer] Origin check - isNullOrigin:', nullOrigin, 'window.origin:', window.origin);

        // In null-origin contexts, blob URLs don't work - use data URL directly
        // But this may fail for large videos!
        if (nullOrigin) {
          console.log('[MediaViewer] Null origin detected, using data URL directly (may fail for large files)');
          return dataUrl;
        }

        // Check cache first
        if (blobUrlCache.has(dataUrl)) {
          return blobUrlCache.get(dataUrl);
        }

        try {
          // Parse data URL
          const [header, base64Data] = dataUrl.split(',');
          const mimeMatch = header.match(/data:([^;]+)/);
          if (!mimeMatch) return dataUrl;

          const mimeType = mimeMatch[1];
          const byteCharacters = atob(base64Data);
          const byteNumbers = new Array(byteCharacters.length);

          for (let i = 0; i < byteCharacters.length; i++) {
            byteNumbers[i] = byteCharacters.charCodeAt(i);
          }

          const byteArray = new Uint8Array(byteNumbers);
          const blob = new Blob([byteArray], { type: mimeType });
          const blobUrl = URL.createObjectURL(blob);

          // Cache it
          blobUrlCache.set(dataUrl, blobUrl);
          console.log('[MediaViewer] Converted data URL to blob URL:', blobUrl.substring(0, 50));

          return blobUrl;
        } catch (e) {
          console.error('[MediaViewer] Failed to convert data URL to blob:', e);
          return dataUrl;
        }
      }

      /**
       * Prepare URL for use - converts data URLs to blob URLs if needed
       */
      function prepareMediaUrl(url) {
        if (!url) return null;
        if (url.startsWith('data:')) {
          return dataUrlToBlobUrl(url);
        }
        return url;
      }

      // Embed platforms configuration
      const EMBED_PLATFORMS = {
        youtube: {
          patterns: [
            /youtube\.com\/watch\?v=([^&]+)/,
            /youtube\.com\/embed\/([^?]+)/,
            /youtu\.be\/([^?]+)/,
            /youtube\.com\/shorts\/([^?]+)/
          ],
          // Use youtube.com directly (not nocookie) with minimal parameters
          // Adding origin parameter helps with postMessage communication
          embedUrl: (id, opts) => {
            const params = new URLSearchParams({
              autoplay: opts.autoplay ? '1' : '0',
              mute: opts.muted ? '1' : '0',
              loop: opts.loop ? '1' : '0',
              rel: '0',
              modestbranding: '1',
              playsinline: '1',
              // These parameters help with sandboxed contexts
              enablejsapi: '0',  // Disable JS API to avoid errors
              origin: window.location.origin
            });
            return `https://www.youtube.com/embed/${id}?${params.toString()}`;
          }
        },
        vimeo: {
          patterns: [/vimeo\.com\/(\d+)/],
          embedUrl: (id, opts) =>
            `https://player.vimeo.com/video/${id}?autoplay=${opts.autoplay ? 1 : 0}&muted=${opts.muted ? 1 : 0}&loop=${opts.loop ? 1 : 0}&background=1`
        },
        twitch: {
          patterns: [
            /twitch\.tv\/videos\/(\d+)/,
            /twitch\.tv\/([^/?]+)$/
          ],
          embedUrl: (id, opts, isVideo) => {
            const parent = location.hostname || 'localhost';
            return isVideo
              ? `https://player.twitch.tv/?video=${id}&parent=${parent}&autoplay=${opts.autoplay}`
              : `https://player.twitch.tv/?channel=${id}&parent=${parent}&autoplay=${opts.autoplay}&muted=${opts.muted}`;
          }
        },
        dailymotion: {
          patterns: [/dailymotion\.com\/video\/([^_?]+)/],
          embedUrl: (id, opts) =>
            `https://www.dailymotion.com/embed/video/${id}?autoplay=${opts.autoplay ? 1 : 0}&mute=${opts.muted ? 1 : 0}`
        }
      };

      // ==========================================================================
      // UTILITY FUNCTIONS
      // ==========================================================================

      /**
       * Determine media type from URL and/or mimeType
       * @param {string} url - The media URL
       * @param {string} mimeType - Optional MIME type from blob
       * @returns {'video'|'image'|'audio'|'unknown'|null}
       */
      function getMediaType(url, mimeType = '') {
        if (!url) return null;

        // First, check mimeType if provided (most reliable for blobs)
        if (mimeType) {
          if (mimeType.startsWith('video/')) return 'video';
          if (mimeType.startsWith('image/')) return 'image';
          if (mimeType.startsWith('audio/')) return 'audio';
        }

        // Check for data URLs
        if (url.startsWith('data:')) {
          if (url.startsWith('data:video/')) return 'video';
          if (url.startsWith('data:image/')) return 'image';
          if (url.startsWith('data:audio/')) return 'audio';
          return null;
        }

        // Check for blob URLs - if no mimeType provided, return unknown
        if (url.startsWith('blob:')) {
          // If we have no mimeType, we can't determine the type
          return 'unknown';
        }

        // Extract extension from URL
        try {
          const urlObj = new URL(url);
          const pathname = urlObj.pathname.toLowerCase();
          const extension = pathname.split('.').pop();

          if (VIDEO_EXTENSIONS.includes(extension)) return 'video';
          if (IMAGE_EXTENSIONS.includes(extension)) return 'image';
          if (AUDIO_EXTENSIONS.includes(extension)) return 'audio';
        } catch (e) {
          // Invalid URL, try extension from string
          const extension = url.split('.').pop()?.toLowerCase().split('?')[0];
          if (VIDEO_EXTENSIONS.includes(extension)) return 'video';
          if (IMAGE_EXTENSIONS.includes(extension)) return 'image';
          if (AUDIO_EXTENSIONS.includes(extension)) return 'audio';
        }

        // Check common video hosting patterns
        if (url.includes('youtube.com') || url.includes('youtu.be') ||
            url.includes('vimeo.com') || url.includes('dailymotion.com')) {
          // Note: Direct embedding would require iframe, not supported in sandbox
          return null;
        }

        return 'unknown';
      }

      function buildFilterString(settings) {
        const filters = [];

        if (settings.blur > 0) {
          filters.push(`blur(${settings.blur}px)`);
        }
        if (settings.brightness !== 100) {
          filters.push(`brightness(${settings.brightness}%)`);
        }
        if (settings.contrast !== 100) {
          filters.push(`contrast(${settings.contrast}%)`);
        }
        if (settings.saturate !== 100) {
          filters.push(`saturate(${settings.saturate}%)`);
        }
        if (settings.hueRotate > 0) {
          filters.push(`hue-rotate(${settings.hueRotate}deg)`);
        }

        return filters.length > 0 ? filters.join(' ') : 'none';
      }

      function parseEmbedUrl(url, settings) {
        if (!url) return null;

        const opts = {
          autoplay: settings.autoplay ?? true,
          muted: settings.muted ?? true,
          loop: settings.loop ?? false
        };

        for (const [platform, config] of Object.entries(EMBED_PLATFORMS)) {
          for (let i = 0; i < config.patterns.length; i++) {
            const pattern = config.patterns[i];
            const match = url.match(pattern);
            if (match) {
              const id = match[1];
              // For Twitch, check if it's a video or channel
              const isVideo = platform === 'twitch' && url.includes('/videos/');
              return {
                platform,
                embedUrl: config.embedUrl(id, opts, isVideo),
                videoId: id
              };
            }
          }
        }

        return null; // Platform not recognized
      }

      function showLoading() {
        loadingEl.classList.remove('hidden');
        fallbackEl.classList.add('hidden');
      }

      function hideLoading() {
        loadingEl.classList.add('hidden');
      }

      function showFallback(message) {
        hideLoading();
        fallbackText.textContent = message || api.config.fallbackText || 'Media unavailable';
        fallbackEl.classList.remove('hidden');
        if (currentMediaEl) {
          currentMediaEl.classList.add('hidden');
        }
      }

      function hideFallback() {
        fallbackEl.classList.add('hidden');
      }

      // ==========================================================================
      // MEDIA CREATION
      // ==========================================================================

      function createImageElement(url, settings) {
        const img = document.createElement('img');
        img.className = 'media-element';
        img.alt = 'Media content';
        img.draggable = false;

        let loadHandled = false;
        let pollingInterval = null;

        const handleLoad = () => {
          if (loadHandled) {
            console.log('[MediaViewer] handleLoad already called, skipping');
            return;
          }
          // Check if this image is still in the DOM (not replaced by another loadMedia call)
          if (!img.parentNode) {
            console.log('[MediaViewer] Image not in DOM yet, deferring handleLoad');
            // Defer to next tick - image might be about to be appended
            setTimeout(() => {
              if (!loadHandled && img.parentNode) {
                handleLoad();
              } else if (!loadHandled) {
                console.log('[MediaViewer] Image still not in DOM, giving up');
              }
            }, 10);
            return;
          }
          loadHandled = true;
          if (pollingInterval) clearInterval(pollingInterval);
          console.log('[MediaViewer] Image loaded successfully, dimensions:', img.naturalWidth, 'x', img.naturalHeight);

          // Force hide loading and fallback
          loadingEl.classList.add('hidden');
          fallbackEl.classList.add('hidden');

          // Force image visibility
          img.classList.remove('hidden');
          img.style.display = 'block';
          img.style.visibility = 'visible';

          // Debug: log computed styles
          const computedStyle = window.getComputedStyle(img);
          console.log('[MediaViewer] Image styles:', {
            display: computedStyle.display,
            visibility: computedStyle.visibility,
            opacity: computedStyle.opacity,
            width: computedStyle.width,
            height: computedStyle.height,
            position: computedStyle.position
          });
          console.log('[MediaViewer] Fallback hidden:', fallbackEl.classList.contains('hidden'));
          console.log('[MediaViewer] Loading hidden:', loadingEl.classList.contains('hidden'));

          api.renderComplete();
        };

        img.onload = handleLoad;

        img.onerror = () => {
          if (loadHandled) return;
          if (pollingInterval) clearInterval(pollingInterval);
          loadHandled = true;
          console.error('[MediaViewer] Failed to load image:', url);
          showFallback(settings.fallbackText);
          api.renderComplete(); // Signal done even on error
        };

        img.src = url;

        // Fallback for blob:null URLs where onload may not fire in sandboxed iframes
        // Check if image is already complete (cached or blob URL quirk)
        if (img.complete && img.naturalWidth > 0) {
          console.log('[MediaViewer] Image already complete (sync load)');
          // Use setTimeout to ensure img is appended to DOM first
          setTimeout(() => handleLoad(), 0);
        } else if (url.startsWith('blob:')) {
          // For blob URLs (including blob:null), poll for image completion as onload is unreliable
          pollingInterval = setInterval(() => {
            if (loadHandled || !img.parentNode) {
              clearInterval(pollingInterval);
              pollingInterval = null;
              return;
            }
            if (img.complete && img.naturalWidth > 0) {
              console.log('[MediaViewer] Image loaded (detected via polling)');
              clearInterval(pollingInterval);
              pollingInterval = null;
              handleLoad();
            }
          }, 50);

          // Stop polling after 5 seconds
          setTimeout(() => {
            if (pollingInterval) {
              clearInterval(pollingInterval);
              pollingInterval = null;
            }
            if (!loadHandled && img.parentNode && img.complete && img.naturalWidth > 0) {
              handleLoad();
            }
          }, 5000);
        }

        return img;
      }

      function createVideoElement(url, settings, mimeType = '') {
        const video = document.createElement('video');
        video.className = 'media-element';

        // IMPORTANT: Video is ALWAYS muted in the iframe due to sandbox restrictions
        // Audio is handled by the parent via api.audio (parent-managed audio)
        video.autoplay = settings.autoplay && !isPaused;
        video.loop = settings.loop;
        video.muted = true;  // Always muted - audio via parent
        video.volume = 1;    // Volume doesn't matter when muted
        video.controls = settings.showControls;
        video.playbackRate = settings.playbackRate;
        video.playsInline = true;
        video.preload = 'auto';

        // Track if we've already signaled render complete
        let renderCompleted = false;
        const signalRenderComplete = () => {
          if (!renderCompleted) {
            renderCompleted = true;
            hideLoading();
            hideFallback();
            video.classList.remove('hidden');
            api.renderComplete();
            console.log('[MediaViewer] Video render complete signaled');
          }
        };

        // Fallback timeout: signal render complete after 8s even if video not fully loaded
        // This prevents blocking thumbnail generation for slow-loading videos
        const loadTimeout = setTimeout(() => {
          if (!renderCompleted) {
            console.warn('[MediaViewer] Video load timeout (8s), signaling render complete anyway');
            signalRenderComplete();
          }
        }, 8000);

        video.onloadedmetadata = () => {
          // Metadata loaded - we know video dimensions, can show poster/first frame
          console.log('[MediaViewer] Video metadata loaded');
        };

        video.onloadeddata = () => {
          clearTimeout(loadTimeout);
          signalRenderComplete();

          // If user wants sound (not muted in settings), start parent audio
          if (!settings.muted) {
            startParentAudio(settings);
          }
        };

        video.onerror = (e) => {
          clearTimeout(loadTimeout);
          // Ignore transient errors if video is actually loading or has a source
          // networkState: 0=EMPTY, 1=IDLE, 2=LOADING, 3=NO_SOURCE
          // readyState: 0=HAVE_NOTHING, 1+=has data
          if (video.readyState > 0 || video.networkState === 2) {
            console.warn('[MediaViewer] Video error (transient, still loading):', video.error?.message);
            return;
          }
          console.error('[MediaViewer] Failed to load video:', url.substring(0, 100) + '...', e);
          console.error('[MediaViewer] Video error code:', video.error?.code, 'message:', video.error?.message);
          showFallback(settings.fallbackText);
          api.renderComplete(); // Signal done even on error
        };

        // Handle autoplay failures (browser restrictions)
        video.onplay = () => {
          console.log('[MediaViewer] Video playing');
          // Sync audio when video plays
          if (usingParentAudio) {
            api.audio.resume();
          }
        };

        video.onpause = () => {
          console.log('[MediaViewer] Video paused');
          // Sync audio when video pauses
          if (usingParentAudio && !video.ended) {
            api.audio.pause();
          }
        };

        video.onseeked = () => {
          // Sync audio position when user seeks in video
          if (usingParentAudio) {
            api.audio.seek(video.currentTime);
          }
        };

        video.onended = () => {
          console.log('[MediaViewer] Video ended');
          if (usingParentAudio && !settings.loop) {
            api.audio.stop();
          }
        };

        // For blob URLs and data URLs, set src directly (more reliable)
        // For regular URLs, use source element with MIME type detection
        if (url.startsWith('data:') || url.startsWith('blob:')) {
          console.log('[MediaViewer] Setting video.src directly for', url.startsWith('blob:') ? 'blob URL' : 'data URL');
          video.src = url;
        } else {
          const source = document.createElement('source');
          source.src = url;

          // Try to determine MIME type from extension or use provided mimeType
          let detectedMimeType = mimeType;
          if (!detectedMimeType) {
            const ext = url.split('.').pop()?.toLowerCase().split('?')[0];
            const mimeTypes = {
              mp4: 'video/mp4',
              webm: 'video/webm',
              ogg: 'video/ogg',
              mov: 'video/quicktime',
              m4v: 'video/mp4'
            };
            detectedMimeType = mimeTypes[ext] || '';
          }

          if (detectedMimeType) {
            source.type = detectedMimeType;
          }

          video.appendChild(source);
        }

        return video;
      }

      /**
       * Start parent-managed audio for video
       * The parent plays the same audio source and we sync playback
       */
      function startParentAudio(settings) {
        console.log('[MediaViewer] Starting parent-managed audio');
        usingParentAudio = true;

        // Clean up previous listener
        if (audioUnsubscribe) {
          audioUnsubscribe();
          audioUnsubscribe = null;
        }

        // Get the audio source - use mediaFile settingKey for file sources
        const source = settings.sourceType === 'file' ? 'mediaFile' : settings.mediaUrl;

        // Play audio via parent with current settings
        api.audio.play(source, {
          volume: (settings.volume ?? 80) / 100,
          loop: settings.loop,
          playbackRate: settings.playbackRate,
          startTime: currentMediaEl?.currentTime || 0
        });

        // Listen for audio state changes to sync with video
        audioUnsubscribe = api.audio.onStateChange((state) => {
          if (!currentMediaEl || currentMediaEl.tagName !== 'VIDEO') return;

          // Sync video position if audio drifts more than 0.3s
          if (state.status === 'playing') {
            const drift = Math.abs(currentMediaEl.currentTime - state.currentTime);
            if (drift > 0.3) {
              console.log('[MediaViewer] Syncing video to audio, drift:', drift.toFixed(2) + 's');
              currentMediaEl.currentTime = state.currentTime;
            }
          }
        });
      }

      /**
       * Stop parent-managed audio
       */
      function stopParentAudio() {
        if (usingParentAudio) {
          console.log('[MediaViewer] Stopping parent-managed audio');
          api.audio.stop();
          usingParentAudio = false;
          if (audioUnsubscribe) {
            audioUnsubscribe();
            audioUnsubscribe = null;
          }
        }
      }

      function createAudioElement(url, settings, mimeType = '') {
        const audio = document.createElement('audio');
        audio.className = 'media-element audio-element';

        // Audio attributes
        audio.autoplay = settings.autoplay && !isPaused;
        audio.loop = settings.loop;
        audio.muted = settings.muted;
        audio.volume = (settings.volume ?? 80) / 100;
        audio.controls = settings.showControls ?? true;  // Show controls by default for audio
        audio.playbackRate = settings.playbackRate ?? 1;
        audio.preload = 'auto';

        audio.onloadeddata = () => {
          hideLoading();
          hideFallback();
          audio.classList.remove('hidden');
          api.renderComplete();
        };

        audio.onerror = (e) => {
          console.error('[MediaViewer] Failed to load audio:', url.substring(0, 100) + '...', e);
          console.error('[MediaViewer] Audio error code:', audio.error?.code, 'message:', audio.error?.message);
          showFallback(settings.fallbackText);
          api.renderComplete(); // Signal done even on error
        };

        audio.onplay = () => {
          console.log('[MediaViewer] Audio playing');
        };

        // For blob URLs and data URLs, set src directly (more reliable)
        // For regular URLs, use source element with MIME type detection
        if (url.startsWith('data:') || url.startsWith('blob:')) {
          console.log('[MediaViewer] Setting audio.src directly for', url.startsWith('blob:') ? 'blob URL' : 'data URL');
          audio.src = url;
        } else {
          const source = document.createElement('source');
          source.src = url;

          // Try to determine MIME type from extension or use provided mimeType
          let detectedMimeType = mimeType;
          if (!detectedMimeType) {
            const ext = url.split('.').pop()?.toLowerCase().split('?')[0];
            const mimeTypes = {
              mp3: 'audio/mpeg',
              wav: 'audio/wav',
              ogg: 'audio/ogg',
              flac: 'audio/flac',
              aac: 'audio/aac',
              m4a: 'audio/mp4',
              opus: 'audio/opus',
              weba: 'audio/webm',
              wma: 'audio/x-ms-wma'
            };
            detectedMimeType = mimeTypes[ext] || '';
          }

          if (detectedMimeType) {
            source.type = detectedMimeType;
          }

          audio.appendChild(source);
        }

        return audio;
      }

      function createEmbedElement(embedData, settings) {
        const iframe = document.createElement('iframe');
        iframe.className = 'media-element embed-frame';
        iframe.frameBorder = '0';
        iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
        iframe.allowFullscreen = true;
        iframe.setAttribute('referrerpolicy', 'no-referrer-when-downgrade');

        // For cross-origin iframes, onload may not fire reliably
        // Show iframe immediately and hide loading after a short delay
        iframe.onload = () => {
          hideLoading();
          hideFallback();
          api.renderComplete();
          console.log(`[MediaViewer] ${embedData.platform} embed loaded`);
        };

        iframe.onerror = () => {
          console.error(`[MediaViewer] Failed to load ${embedData.platform} embed`);
          showFallback(`Failed to load ${embedData.platform} video`);
          api.renderComplete(); // Signal done even on error
        };

        // Set src after setting up handlers
        iframe.src = embedData.embedUrl;

        // Fallback: if onload doesn't fire within 3s, show anyway
        setTimeout(() => {
          hideLoading();
          hideFallback();
        }, 3000);

        return iframe;
      }

      // ==========================================================================
      // APPLY SETTINGS
      // ==========================================================================

      function applyStyles(element, settings) {
        if (!element) return;

        element.style.objectFit = settings.objectFit || 'contain';
        element.style.objectPosition = settings.objectPosition || 'center';
        element.style.opacity = (settings.opacity ?? 100) / 100;
        element.style.filter = buildFilterString(settings);
        element.style.borderRadius = `${settings.borderRadius || 0}px`;
      }

      function applyContainerStyles(settings) {
        container.style.backgroundColor = settings.backgroundColor || 'transparent';
        container.style.borderRadius = `${settings.borderRadius || 0}px`;
      }

      function applyVideoSettings(video, settings) {
        if (!video || video.tagName !== 'VIDEO') return;

        // For VIDEO elements, video is always muted (audio via parent)
        video.loop = settings.loop;
        video.controls = settings.showControls;

        if (video.playbackRate !== settings.playbackRate) {
          video.playbackRate = settings.playbackRate;
        }

        // Handle muted setting changes via parent audio
        if (!settings.muted && !usingParentAudio) {
          // User wants sound - start parent audio
          startParentAudio(settings);
        } else if (settings.muted && usingParentAudio) {
          // User muted - stop parent audio
          stopParentAudio();
        }

        // Sync audio settings with parent
        if (usingParentAudio) {
          api.audio.setVolume((settings.volume ?? 80) / 100);
          api.audio.setLoop(settings.loop);
          api.audio.setPlaybackRate(settings.playbackRate);
        }

        // Handle autoplay changes
        if (settings.autoplay && video.paused && !isPaused) {
          video.play().catch(e => console.log('[MediaViewer] Autoplay blocked:', e));
        } else if (!settings.autoplay && !video.paused) {
          video.pause();
        }
      }

      function applyAudioElementSettings(audio, settings) {
        if (!audio || audio.tagName !== 'AUDIO') return;

        // For AUDIO elements (not video), we still use parent audio API
        audio.loop = settings.loop;
        audio.controls = settings.showControls ?? true;

        // Handle autoplay changes
        if (settings.autoplay && audio.paused && !isPaused) {
          audio.play().catch(e => console.log('[MediaViewer] Autoplay blocked:', e));
        } else if (!settings.autoplay && !audio.paused) {
          audio.pause();
        }
      }

      // ==========================================================================
      // MEDIA LOADING
      // ==========================================================================

      async function getMediaSource(settings) {
        // Use sourceType to determine which field to use
        switch (settings.sourceType) {
          case 'file':
            // Resolve placeholder/FileReference to actual blob URL with mimeType
            const fileResult = await resolveSettingValue(settings.mediaFile, 'mediaFile');
            if (fileResult) {
              return { type: 'file', url: fileResult.url, mimeType: fileResult.mimeType };
            }
            return { type: 'file', url: null, mimeType: '' };
          case 'url':
          default:
            const urlResult = await resolveSettingValue(settings.mediaUrl, 'mediaUrl');
            if (urlResult) {
              return { type: 'url', url: urlResult.url, mimeType: urlResult.mimeType };
            }
            return { type: 'url', url: settings.mediaUrl || null, mimeType: '' };
        }
      }

      // Guard to prevent race conditions when multiple loadMedia calls overlap
      let loadMediaVersion = 0;

      async function loadMedia(settings) {
        // Increment version - any older loadMedia call should abort
        const thisVersion = ++loadMediaVersion;
        console.log('[MediaViewer] loadMedia started, version:', thisVersion);

        showLoading();

        const source = await getMediaSource(settings);

        // Check if a newer loadMedia was started while we were waiting
        if (thisVersion !== loadMediaVersion) {
          console.log('[MediaViewer] loadMedia aborted (newer call started), version:', thisVersion, 'current:', loadMediaVersion);
          return;
        }

        console.log('[MediaViewer] loadMedia called, source:', {
          type: source.type,
          urlLength: source.url?.length || 0,
          urlStart: source.url?.substring(0, 100) || 'null',
          mimeType: source.mimeType || 'none'
        });

        // Request network permission for external URLs
        if (source.type === 'url' && source.url && !source.url.startsWith('data:') && !source.url.startsWith('blob:')) {
          try {
            const urlObj = new URL(source.url);
            const domain = urlObj.hostname;

            console.log('[MediaViewer] Requesting network access for:', domain);

            if (api.network && api.network.requestAccess) {
              const accessResult = await api.network.requestAccess(domain, `Load media from ${domain}`);

              if (!accessResult.granted) {
                console.warn('[MediaViewer] Network access denied for:', domain);
                showFallback('Network access denied');
                api.renderComplete(); // Signal done even on error
                return;
              }

              console.log('[MediaViewer] Network access granted for:', domain);
            }
          } catch (e) {
            console.warn('[MediaViewer] Could not parse URL for network permission:', e);
          }
        }

        // If we're waiting for a file access response (FileReference)
        if (!source.url && source.type === 'file') {
          const rawValue = settings.mediaFile;

          // FileReference - waiting for user to approve
          if (isFileReference(rawValue)) {
            console.log('[MediaViewer] Waiting for file access approval:', rawValue.filename);
            showFallback('En attente d\'autorisation...');
            return;
          }

          // Legacy blob placeholder
          if (rawValue && typeof rawValue === 'string' && rawValue.startsWith('__blob_')) {
            console.log('[MediaViewer] Waiting for legacy blob to arrive:', rawValue);
            return;  // Will be called again when blob arrives
          }
        }

        if (!source.url) {
          const messages = {
            'file': 'No file uploaded',
            'url': 'No URL configured'
          };
          showFallback(messages[settings.sourceType] || 'No URL configured');
          api.renderComplete(); // Signal done even with no media
          return;
        }

        // Check if URL is truncated or empty
        if (source.url.length < 50 && source.url.startsWith('data:')) {
          console.error('[MediaViewer] Data URL appears truncated! Length:', source.url.length);
          showFallback('File data is corrupted or too large');
          api.renderComplete(); // Signal done even on error
          return;
        }

        // Clear previous media
        if (currentMediaEl) {
          if (currentMediaEl.tagName === 'VIDEO' || currentMediaEl.tagName === 'AUDIO') {
            currentMediaEl.pause();
            // Remove error handler before cleanup to prevent spurious error events
            currentMediaEl.onerror = null;
            currentMediaEl.onloadeddata = null;
          }
          currentMediaEl.remove();
          currentMediaEl = null;
        }

        // Prepare URL (convert data: to blob: for CSP compatibility)
        const mediaUrl = prepareMediaUrl(source.url);

        // For URL sources, try to detect embed platforms first
        if (source.type === 'url') {
          const embedData = parseEmbedUrl(source.url, settings);
          if (embedData) {
            console.log('[MediaViewer] Loading embed:', embedData.platform, embedData.videoId);
            currentMediaEl = createEmbedElement(embedData, settings);
            applyStyles(currentMediaEl, settings);
            applyContainerStyles(settings);
            mediaWrapper.appendChild(currentMediaEl);
            return;
          }
        }

        // Handle direct media (images, videos, audio, uploaded files)
        const mediaType = getMediaType(source.url, source.mimeType);
        console.log('[MediaViewer] Loading media:', mediaUrl.substring(0, 50) + '...', 'type:', mediaType, 'mimeType:', source.mimeType);

        if (mediaType === 'video') {
          currentMediaEl = createVideoElement(mediaUrl, settings, source.mimeType);
        } else if (mediaType === 'audio') {
          currentMediaEl = createAudioElement(mediaUrl, settings, source.mimeType);
        } else if (mediaType === 'image') {
          currentMediaEl = createImageElement(mediaUrl, settings);
        } else if (mediaType === 'unknown') {
          // Try as image first, then video, then audio
          currentMediaEl = createImageElement(mediaUrl, settings);
          currentMediaEl.onerror = () => {
            console.log('[MediaViewer] Image failed, trying as video');
            currentMediaEl.remove();
            currentMediaEl = createVideoElement(mediaUrl, settings, source.mimeType);
            currentMediaEl.onerror = () => {
              console.log('[MediaViewer] Video failed, trying as audio');
              currentMediaEl.remove();
              currentMediaEl = createAudioElement(mediaUrl, settings, source.mimeType);
              applyStyles(currentMediaEl, settings);
              mediaWrapper.appendChild(currentMediaEl);
            };
            applyStyles(currentMediaEl, settings);
            mediaWrapper.appendChild(currentMediaEl);
          };
        } else {
          showFallback('Unsupported media type');
          api.renderComplete(); // Signal done even on error
          return;
        }

        applyStyles(currentMediaEl, settings);
        applyContainerStyles(settings);
        mediaWrapper.appendChild(currentMediaEl);
      }

      function setupRefreshTimer(intervalMinutes) {
        if (refreshTimer) {
          clearInterval(refreshTimer);
          refreshTimer = null;
        }

        if (intervalMinutes > 0) {
          const intervalMs = intervalMinutes * 60 * 1000;
          refreshTimer = setInterval(() => {
            console.log('[MediaViewer] Auto-refreshing media');
            loadMedia(api.config);
          }, intervalMs);
        }
      }

      // ==========================================================================
      // EVENT HANDLERS
      // ==========================================================================

      api.onSettingsChange((settings, changedKeys) => {
        console.log('[MediaViewer] Settings changed:', changedKeys);

        // Check if media source changed
        const mediaChanged = changedKeys.includes('mediaUrl') ||
                            changedKeys.includes('mediaFile') ||
                            changedKeys.includes('sourceType');

        if (mediaChanged) {
          // Stop current audio before loading new media
          stopParentAudio();
          loadMedia(settings);
        } else {
          // Apply style changes without reloading
          applyStyles(currentMediaEl, settings);
          applyContainerStyles(settings);

          // Element-specific settings
          if (currentMediaEl?.tagName === 'VIDEO') {
            applyVideoSettings(currentMediaEl, settings);
          } else if (currentMediaEl?.tagName === 'AUDIO') {
            applyAudioElementSettings(currentMediaEl, settings);
          }
        }

        // Handle refresh interval change
        if (changedKeys.includes('refreshInterval')) {
          setupRefreshTimer(settings.refreshInterval);
        }

        // Update fallback text
        if (changedKeys.includes('fallbackText') && !fallbackEl.classList.contains('hidden')) {
          fallbackText.textContent = settings.fallbackText;
        }
      });

      api.onEvent('viewport:resize', ({ width, height }) => {
        console.log(`[MediaViewer] Viewport resized: ${width}x${height}`);
        // Media elements auto-resize via CSS, no action needed
      });

      api.onEvent('theme:change', ({ theme }) => {
        console.log(`[MediaViewer] Theme changed: ${theme}`);
        document.body.dataset.theme = theme;
      });

      api.onEvent('visibility:change', ({ visible }) => {
        console.log(`[MediaViewer] Visibility changed: ${visible}`);
        const isPlayableMedia = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';

        if (isPlayableMedia) {
          if (!visible && !currentMediaEl.paused) {
            currentMediaEl.pause();
            // Also pause parent audio
            if (usingParentAudio) {
              api.audio.pause();
            }
          } else if (visible && api.config.autoplay && !isPaused) {
            currentMediaEl.play().catch(() => {});
            // Also resume parent audio
            if (usingParentAudio) {
              api.audio.resume();
            }
          }
        }
      });

      api.onMount(() => {
        console.log('[MediaViewer] Mounted');
      });

      api.onUnmount(() => {
        console.log('[MediaViewer] Unmounting - cleaning up');
        if (refreshTimer) {
          clearInterval(refreshTimer);
        }
        // Stop parent audio
        stopParentAudio();
        if (currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO') {
          currentMediaEl.pause();
        }
        // Clean up blob URLs to prevent memory leaks
        for (const blobUrl of blobUrlCache.values()) {
          URL.revokeObjectURL(blobUrl);
        }
        blobUrlCache.clear();
        // Clean up received blobs from host
        for (const blobUrl of receivedBlobs.values()) {
          URL.revokeObjectURL(blobUrl);
        }
        receivedBlobs.clear();
        // Clean up granted blob URLs from file access API (v2.6)
        for (const { blobUrl } of grantedBlobUrls.values()) {
          URL.revokeObjectURL(blobUrl);
        }
        grantedBlobUrls.clear();
      });

      api.onPause(() => {
        console.log('[MediaViewer] Paused');
        isPaused = true;
        const isPlayableMedia = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';
        if (isPlayableMedia && !currentMediaEl.paused) {
          currentMediaEl.pause();
        }
        // Also pause parent audio
        if (usingParentAudio) {
          api.audio.pause();
        }
      });

      api.onResume(() => {
        console.log('[MediaViewer] Resumed');
        isPaused = false;
        const isPlayableMedia = currentMediaEl?.tagName === 'VIDEO' || currentMediaEl?.tagName === 'AUDIO';
        if (isPlayableMedia && api.config.autoplay) {
          currentMediaEl.play().catch(() => {});
        }
        // Also resume parent audio
        if (usingParentAudio) {
          api.audio.resume();
        }
      });

      // ==========================================================================
      // INITIALIZATION
      // ==========================================================================

      async function init() {
        // Refresh API reference (in case it was injected after script load)
        api = window.MyWallpaper;

        console.log('[MediaViewer] Initializing...', { hasApi: !!api, hasConfig: !!(api && api.config) });

        if (!api) {
          console.error('[MediaViewer] SDK not available!');
          return;
        }

        if (!api.config) {
          console.error('[MediaViewer] No config available!');
        }

        try {
          // Apply initial settings and WAIT for media to load
          await loadMedia(api.config || {});
          setupRefreshTimer((api.config || {}).refreshInterval);
        } catch (e) {
          console.error('[MediaViewer] Error loading media:', e);
          api.renderComplete(); // Signal done even on error
        }

        // Signal ready
        api.ready({
          capabilities: ['hot-reload'],
          subscribedEvents: ['viewport:resize', 'theme:change', 'visibility:change']
        });

        console.log('[MediaViewer] Ready! SDK v' + api.version);
      }

      // Wait for SDK if not available yet
      if (window.MyWallpaper) {
        init();
      } else {
        console.log('[MediaViewer] Waiting for SDK...');
        window.addEventListener('mywallpaper:ready', init);
      }

    })();
  </script>
</body>
</html>
